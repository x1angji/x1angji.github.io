<!DOCTYPE html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><title>C++查漏补缺 | x1ang</title><meta name=keywords content=C++><meta name=author content=x1ang><meta name=copyright content=x1ang><meta name=format-detection content="telephone=no"><meta name=theme-color content=#f7f9fe><meta name=mobile-web-app-capable content=yes><meta name=apple-touch-fullscreen content=yes><meta name=apple-mobile-web-app-title content=C++查漏补缺><meta name=application-name content=C++查漏补缺><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f7f9fe><meta property=og:type content=article><meta property=og:title content=C++查漏补缺><meta property=og:url content=https://x1ang.com/2025/03/15/C-查漏补缺/index.html><meta property=og:site_name content=x1ang><meta property=og:description content="一、吸佳佳查漏补缺编译器c++11移动语义它允许将一个对象的所有权从一个对象转移到另一个对象，而不需要进行数据的拷贝和搬迁。使程序在内存管理方面更加高效。 移动语义是通过右值引用来实现的，右值引用的语法是 &amp;amp;&amp;amp;，这是一种新的引用类型，用于表示即将销毁的对象。 但需要注意，使用move"><meta property=og:locale content=zh-CN><meta property=og:image content="https://assets.blog.x1ang.com/default_cover_3.webp?_r_=cac6baa4-5d41-2724-b865-44d3c48e3c49"><meta property=article:author content=x1ang><meta property=article:tag content=笔记、风光><meta name=twitter:card content=summary><meta name=twitter:image content="https://assets.blog.x1ang.com/default_cover_3.webp?_r_=cac6baa4-5d41-2724-b865-44d3c48e3c49"><meta name=description content="一、吸佳佳查漏补缺编译器c++11移动语义它允许将一个对象的所有权从一个对象转移到另一个对象，而不需要进行数据的拷贝和搬迁。使程序在内存管理方面更加高效。 移动语义是通过右值引用来实现的，右值引用的语法是 &amp;amp;&amp;amp;，这是一种新的引用类型，用于表示即将销毁的对象。 但需要注意，使用move"><link rel="shortcut icon" href=https://assets.blog.x1ang.com/config/hutao-icon.webp><link rel=canonical href=https://x1ang.com/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ ><link rel=preconnect href=//cdn.cbd.int><meta name=google-site-verification content=xxx><meta name=baidu-site-verification content=code-xxx><meta name=msvalidate.01 content=xxx><link rel=stylesheet href=https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css><link rel=stylesheet href=/css/index.css><link rel=stylesheet href=https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css media=print onload='this.media="all"'><script>let GLOBAL_CONFIG={linkPageTop:void 0,peoplecanvas:void 0,postHeadAiDescription:void 0,diytitle:{enable:!0,leaveTitle:"w(ﾟДﾟ)w 不要走！再看看嘛！",backTitle:"♪(^∇^*)欢迎肥来！"},LA51:{enable:!0,ck:"3NaLBWfYov0a5jYz",LingQueMonitorID:"3NaLBWfYov0a5jYz"},greetingBox:{enable:!0,default:"早上中午晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 再坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 宝贝",startTime:12,endTime:14},{greeting:"好急，再坚持一下就下班咯～",startTime:14,endTime:18},{greeting:"🌈充实的一天辛苦啦！",startTime:19,endTime:19},{greeting:"晚上好👋, 决定去哪个平行世界放松了吗😌～",startTime:20,endTime:24}]},twikooEnvId:"https://comment.x1ang.com",commentBarrageConfig:{enable:!0,maxBarrage:1,barrageTime:8e3,accessToken:"",mailMd5:""},music_page_default:"nav_music",root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:void 0,authorStatus:{skills:["🤖️ 数码科技爱好者","🔍 分享与热心帮助"]},algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:330},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!1,limitCount:50,languages:{author:"作者: x1ang",link:"链接: ",source:"来源: x1ang",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#2d3035",position:"top-right"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id=config-diff>var GLOBAL_CONFIG_SITE={configTitle:"x1ang",title:"C++查漏补缺",postAI:"",pageFillDescription:"一、吸佳佳查漏补缺, 编译器, c++11, 移动语义, 左值和右值, 内存管理, 内存分区, 智能指针, auto_ptr（已弃用）, unique_ptr, 1、关键字, inline, new与malloc, const 与 constexpr, volatile, 1.1、储存类, mutable, extern, thread_local, static, 2、Lambda函数与表达, 3、随机数, rand, random_device, mt19937, shuffle, 4、模板, 函数模板, 类模板, 实例, 6、数据结构, 链表（Linked List）, 栈（Stack）, 队列（Queue）, 双端队列（Deque）, 哈希表（Hash Table）, 哈希表的应用, 布隆过滤器, 一致性哈希, 映射（Map）, 集合（Set）, 7、线程和进程, 7.1、进程, 7.2、线程, 7.2.1、原子操作, atomic, 7.2.2、线程同步, 互斥锁, lock_guard, 条件变量, 读写锁, 信号量, 8、C++ 标准库, 8.1、容器, 8.1.1、顺序容器, string, vector, list, deque, 8.1.2、关联容器, set, map, 8.2、容器适配器, stack, queue, priority_queue, 8.3、其他, sstream一吸佳佳查漏补缺编译器移动语义它允许将一个对象的所有权从一个对象转移到另一个对象而不需要进行数据的拷贝和搬迁使程序在内存管理方面更加高效移动语义是通过右值引用来实现的右值引用的语法是这是一种新的引用类型用于表示即将销毁的对象但需要注意使用后原对象的状态是不确定的不应再对其进行操作右值引用只能绑定到一个右值不能绑定到一个左值但是可以使用函数将一个左值强制转换为右值引用从而允许我们使用移动语义左值和右值左值表示了一个占据内存中某个可识别的位置也就是一个地址的对象可寻址的对象右值则使用排除法来定义是不可寻址的常量或在表达式求值过程中创建的无名临时对象短暂性的内存管理内存分区堆区容量大于栈由程序员管理手动申请手动释放程序中动态分配的内存在此区域栈区由系统进行管理的区域主要存放函数的参数以及局部变量栈区的大小可以在编译器中由用户自行设定文字常量区储存常量字符串文字常量区的内存是只读的代码区存放函数体的二进制代码全局静态区储存全局变量和静态变量以及除了字符串以外的其他类型常量其中被初始化的和未被初始化的又可以分为数据段和智能指针将分配的动态内存都交由有生命周期的对象来处理那么在对象过期时让它的析构函数删除指向的内存提供了模板的解决方案已弃用增加和已弃用中重载了和可以直接像普通指针一样使用主要有三大问题复制和赋值会改变资源的所有权不符合人的直觉在容器中使用存在重大风险因为容器内的元素必需支持可复制和可赋值不支持对象数组的操作和用法几乎一样关键字内联函数有时称作编译时期展开函数是一种编程语言结构用来建议编译器将指定的函数体插入并取代每一处调用该函数的地方从而节省了每次调用函数带来的额外时间开支类内部的函数一般会自动内联定义内联函数是一个空间代价换时间的操作在现代处理器上通常代码越小执行越快因为指令缓存利用率高通常编译器比程序设计者更清楚对于一个特定的函数是否合适进行内联扩展一些情况下对于程序员指定的某些内联函数编译器可能更倾向于不使用内联甚至根本无法完成内联完全改变了的定义从原来的优先内联改为容许多次定义被修饰的函数会被定义成弱函数会被其他普通函数覆盖对于原本内联的功能完全交给编译器优化较新的编译器启用优化模式不管对于什么版本的标准都会自动决定函数的内联与是语言中的函数而是中的操作符我的理解是的超集只负责内存的分配而会确保了对象在创建时已经正确初始化申请之后返回的类型是而返回的指针带有类型只负责内存的分配而不会调用类的构造函数而不仅会分配内存而且会自动调用类的构造函数与修饰的变量只能读取一旦被初始化就无法修改可以在运行期间计算得出修饰的对象必须是常量即必须是编译期间可以计算出来的是引入的一方面是为了引入更多的编译时计算能力另一方面也是解决的的双重语义问题在里面很明确只有只读一个语义不会混淆在此基础上增加了常量语义也由关键字来承担引出来一些奇怪的问题把常量语义拆出来交给新引入的关键字例如在标准中只允许使用常量初始化数组如其中在程序运行中才确定不属于常量尽管在语言的标准中支持了变长数组使得很多编译器如允许这种写法但它是编译器扩展的特性不符合的标准行为此时用修饰的变量初始化数组可能会出现未知的问题注意并不强制要求函数在每个使用时都必须在编译时计算结果它只是表示该函数可以在编译时求值如果条件允许的话关键字是一种类型修饰符用它声明的变量对象表示可以被某些编译器未知的因素更改比如操作系统硬件或者其它线程等遇到这个关键字声明的变量编译器对访问该变量的代码就不再进行优化从而可以提供对特殊地址的稳定访问被修饰的变量或对象不会被存入寄存器中总是从内存中读取下面汇编语句的作用就是改变内存中的值为但是又不让编译器知道输出储存类用于定义程序中变量函数的范围可见性和生命周期用于修饰类的成员变量被修饰的成员变量可以被修改即使它们所在的对象是的关键字表示该成员函数不会修改对象中的数据成员关键字允许在成员函数中修改成员变量用于声明具有外部链接的变量或函数它们可以在多个文件之间共享默认情况下全局变量和函数具有存储类在一个文件中使用声明另一个文件中定义的全局变量或函数可以实现跨文件共享用于定义具有线程局部存储期的变量每个线程都有自己的独立副本线程局部变量的生命周期与线程的生命周期相同用于定义静态变量或函数静态变量或函数的性质存储期使用修饰的变量在程序整个运行期间都存在这意味着内存空间在程序启动时分配直到程序结束才释放现代编译器和链接器能对未被使用的静态变量进行优化变量默认具有存储期链接性修饰的变量或函数具有内部链接只能在本文件中访问避免了全局命名冲突如果在头文件定义静态函数被多个调用会生成多份函数代码函数与表达沒有定义任何变量使用未定义变量会引发错误以传值方式传入默认以引用方式传入任何被使用到的外部变量都隐式地以引用方式加以引用任何被使用到的外部变量都隐式地以传值方式加以引用显式地以传值方式加以引用其余变量以引用方式加以引用显式地以引用方式加以引用其余变量以传值方式加以引用另外有一点需要注意对于或的形式表达式可以直接使用指针但是对于的形式如果要使用指针必须显式传入随机数函数包含在头文件中调用后会随机伪随机返回一个值域在到保证均匀分布的变量由于该函数使用的是线性同余方程生成随机数所以循环节并不长一般为即在使用前需要先通过函数设定随机数种子通常采用时间作为种子获取一个在范围中的随机数是算法竞赛中最常用的种子之一包含在头文件中缺点一秒一变精度可以达到纳秒包含在头文件中是一种随机数生成器类型在头文件中如果在下调用会通过系统提供的一个系统噪音收集器来获取真随机数在下就会利用很多数据来计算熵可以近似认为是真随机的值域在也就是的值域范围这个奇怪的名字来源于这个生成随机数的算法梅森旋转算法至于其中的则是代表它生成的随机数的周期可以到达的惊人数量级相比起确实可以避免很多问题而且几乎是最快的伪随机数生成器效率非常高是一个随机数生成器类型在头文件中调用时其会返回一个值域也在如果需要更大的值域范围可以使用唯一的区别就是返回值变成了一个这样写等价于上面注释掉的写法种子为自被引入用于替代在头文件中它必须传入三个参数前两个一样是容器的头尾迭代器最后一个参数是随机数生成器随机数生成器可以是可以是也可以是同样引入用于替代的随机数生成器但是性能不及所以还是推荐一种可能的输出模板模板是泛型编程的基础泛型编程即以一种独立于任何特定类型的方式编写代码模板是创建泛型类或函数的蓝图或公式库容器比如迭代器和算法都是泛型编程的例子它们都使用了模板的概念例如容器只有一个单一的定义而形如或等不同的类型的元素即是通过模板实现的函数模板在这里是函数所使用的数据类型的占位符名称这个名称可以在函数定义中使用函数的主体类模板可以在类被实例化的时候进行指定可以使用一个逗号分隔的列表来定义多个泛型数据类型类的主体实例函数模板的实例返回两个数中的最大值输入可以是类型类模板实例实现了泛型方法来对元素进行入栈出栈操作元素入栈出栈返回栈顶元素如果为空则返回真追加传入元素的副本省去其余函数实现类型的栈类型的栈操作类型的栈操作类型的栈数据结构链表链表是一种动态数据结构由一系列节点组成每个节点包含数据和指向下一个节点的指针动态调整大小不需要提前定义容量插入和删除操作效率高时间复杂度为在链表头部或尾部操作线性查找时间复杂度为插入新节点栈栈是一种后进先出的数据结构常用于递归深度优先搜索等场景只允许在栈顶进行插入和删除操作时间复杂度为输出队列队列是一种先进先出的数据结构常用于广度优先搜索任务调度等场景插入操作在队尾进行删除操作在队头进行时间复杂度为输出双端队列双端队列允许在两端进行插入和删除操作是栈和队列的结合体允许在两端进行插入和删除时间复杂度为输出哈希表将使用哈希函数计算结果取的模然后用一个大小为的链表数组记录数据在取模结果的位置上增加一个存放了和的链表节点查找同理计算哈希值取模找到链表数组中位置遍历链表当链表长度过长触发扩容机制数组长度翻倍重新计算所有数据的位置扩容时间复杂度哈希操作只是在使用上趋近于的水平哈希表是一种通过键值对存储数据的数据结构支持快速查找插入和删除操作中的是哈希表的实现使用哈希函数快速定位元素时间复杂度为不保证元素的顺序输出哈希表的应用布隆过滤器将每个数据通过个哈希函数再取的模计算出个特征值在大小位的位图中记录这个特征值的位置其中所需位图大小需要样本量和允许的失误率计算哈希函数个数也就是特征值个数需要和计算一致性哈希假设三台服务器用于存储数据如何做到负载均衡将某哈希算法的哈希空间虚拟成一个圆环所有的数据计算出来的哈希值都能映射在这个哈希环上对于每台服务器按照负载能力分配不同数量的节点用同样的哈希算法计算每个节点的哈希值也映射到哈希环上节点数量较大时能近似认为是均匀分布的节点之间的数据由顺时针方向上的节点对应的服务器管理这样由于哈希值分布的均匀性和离散性可以做到负载均衡同时如果需要新增服务器或者减少服务器可以直接新增或者删除环上的节点移动数据也只需要移动被影响的节点对应的数据映射是一种有序的键值对容器底层实现是红黑树与不同它保证键的顺序查找插入和删除的时间复杂度为保证元素按键的顺序排列使用二叉搜索树实现输出集合是一种用于存储唯一元素的有序集合底层同样使用红黑树实现它保证元素不重复且有序保证元素的唯一性元素自动按升序排列时间复杂度为输出线程和进程进程进程是操作系统中的一个独立执行单元每个进程都有独立的内存空间程序代码数据和系统资源进程间通信相对复杂通常需要通过进程间通信机制来实现如消息队列信号量管道等进程切换的代价相对较高因为切换时需要保存和恢复完整的上下文信息包括内存寄存器等线程线程是程序执行中的单一顺序控制流多个线程可以在同一个进程中独立运行线程除了线程栈外其他数据都是共享的如果同时读写数据可能造成数据不一致甚至程序崩溃的后果因此线程之间重点关注同步最常解决竞争条件的方式是原子操作其次便是线程同步原子操作原子操作一般都是指不可分割的操作是一系列不可被上下文交换的机器指令这些指令组合在一起就形成了原子操作在多核下当某个核心开始运行原子操作时会先暂停其它内核对内存的操作以保证原子操作不会被其它内核所干扰正常情况下我们想到就是使用来解决上述对临界资源访问的问题使用程序执行不会导致混乱但是每一次循环都要加锁解锁是的程序开销很大而原子操作是通过指令提供的支持因此它的性能相比锁和消息传递会好很多相比较于锁而言原子类型不需要开发者处理加锁和释放锁的问题同时支持修改读取等操作还具备较高的并发性能互斥量的加锁一般是针对一个代码段而原子操作针对的一般都是一个变量为了提高性能提供了原子类型它提供了多线程间的原子操作可以把原子操作理解成一种不需要用到互斥量加锁无锁技术的多线程并发编程方式它定义在头文件中原子类型是封装了一个值的类型它的访问保证不会导致数据的竞争并且可以用于在不同的线程之间同步内存访问这个类型必须有拷贝赋值运算符这就意味着这个类型不能有任何虚函数或虚基类以及必须使用编译器创建的拷贝赋值操作不仅仅是这些自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作模板允许用户使用自定义类型创建一个原子变量安全地读取原子变量的值安全地将值写入原子变量将原子变量的值替换为并返回原子变量的旧值如果原子变量的当前值等于则将其设置为并返回否则将设置为原子变量的当前值并返回与类似但循环直到成功线程同步互斥锁是睡眠等待类型的锁当线程抢互斥锁失败的时候线程会陷入休眠优点就是节省资源缺点就是休眠唤醒会消耗一点时间它有和两种状态一旦获取就会上锁且只能由该线程解锁期间其他线程无法获取自动加锁当一个对象被创建时它会自动为传入的锁加锁自动释放锁当对象超出作用域时它会自动释放锁条件变量并发有互斥和等待两大需求前者是因为线程间存在共享数据依赖而后者是线程间存在依赖条件变量正是为了解决等待需求条件变量本质上也是一个多线程间共享的全局变量它的功能是阻塞线程被阻塞的线程直到接收到条件成立的信号后才能继续执行条件变量并不是锁但它几乎总是和互斥量一起使用的而是线程间的一种通讯机制条件变量本身也不包含条件它被称为条件变量是因为它经常和条件语句一起使用条件变量被用来阻塞一个线程当条件不满足时线程会解开互斥锁并等待条件发生变化一旦其他线程改变了条件变量将通知相应的阻塞线程这些线程重新锁定互斥锁然后执行后续代码最后再解开互斥锁具体流程手动上锁判断条件不满足条件变量自动解锁阻塞线程等待信号自动上锁判断条件满足执行代码手动解锁其他线程准备好条件后发送信号唤醒中括号中为系统封装中括号外需要程序员实现背景轮询模式与事件模式以生产者和消费者模型为例读写锁读写锁也称之为共享独占锁一般用在读操作次数多于写操作次数的场合相较于互斥锁而言读写锁有一定的性能提升应对的是单写多读模型写独占写锁占用时其他线程加读锁或者写锁时都会阻塞并非失败读共享读锁占用时其他线程加写锁时会阻塞加读锁会成功读写锁有两种策略强读同步读锁优先只要写锁没有占用那么就可以加读锁强写同步写锁优先只能等到所有正在等待或者执行的写锁执行完成后才能加读锁大部分读写锁的实现都采用的是强写同步策略对尝试加锁的操作进行排队如果前面已经有尝试加写被锁阻塞住的话后续加读锁也都会被阻塞住尽管当前时刻是读锁占用的状态这样做的目的主要是为了避免写饥饿在多读少写的情况下防止数据修改延迟过高信号量信号量分为有名信号量和无名信号量无名信号量用于线程同步有名信号量一般用于进程之间管理信号量本质上是一个非负的整数计数器用于控制公共资源的访问也被称为原子操作操作等待操作信号量先减一若小于等于则操作被阻塞直到有其他线程通过操作将信号量的值增加至大于从而唤醒等待的线程操作释放操作信号量加一若小于等于表示有线程在等待信号量操作会唤醒其中一个等待的线程信号量允许多个线程同时进入临界区而互斥量只允许一个线程进入临界区可以这样理解互斥锁使用对同一个资源的互斥的方式达到线程同步的目的信号量可以同步多个资源以达到线程同步标准库容器顺序容器使用连接字符串可以获取空格以结尾返回字符串的长度检查字符串是否为空返回从指定位置开始的子字符串返回从开始的个字符查找子字符串在主字符串中的位置从开始查找的位置从开始查找以开头长度为的字符串的位置替换字符串中的某些字符替换从开始的个字符为在指定位置插入内容在处插入在处插入个在字符串末尾添加内容末尾添加删除指定位置的字符或子字符串删除从开始的个字符删除处的一个字符是个类型的迭代器删除从到之间的字符和都是迭代器从指定容器删除指定位置的元素或某段范围内的元素删除指定位置的元素返回值是一个迭代器指向删除元素的下一个元素删除从开始到位置的元素后面的元素会向前移位形成新的容器这样原来指向删除元素的迭代器就失效了注意调用后语义上来说失效了实际上指向的元素变成了下一个元素再执行导致跳过该元素双端队列是在队列的两端都可以进行插入和删除的队列且增删的效率均为支持随机访问在表面上看起来是连续存储的但在底层实现中却不是完全连续而是分段连续的有一个中控器中控器中包含了每一段连续地址的大小开始地址迭代器结束地址迭代器并包含一个指向开始地址的指针实际访问到一个地址的元素需要先访问中控器找到相应的缓冲区再在缓冲区中找到目标元素因此的随机访问是比低效的与比较其头部插入和删除以及扩容时不需要搬移元素因此其效率是必高的与比较其底层是连续空间空间利用率比较高不需要存储额外字段但是有一个致命缺陷不适合遍历因为在遍历时的迭代器要频繁的去检测是否移动到某段小空间的边界导致效率低下而序列式场景中可能需要经常遍历因此在实际中需要线性结构时大多数情况下优先考虑和的应用并不多而目前能看到的一个应用就是用其作为和的底层数据结构关联容器容器适配器适配器是指将一个类型的接口转化为另外一个接口中的容器适配器的意思便是在提供的底层容器的基础上实现我们所希望的功能而向外表现出和容器一样的特点只要支持以下几种操作的容器均可作为和的底层容器检测容器是否为空返回容器中有效元素个数返回容器中第一个元素的引用在容器尾部插入元素删除容器尾部元素优先队列是基于堆这种数据结构实现的允许我们快速访问队列中具有最高或最低优先级的元素但不支持随机访问也不提供迭代器所以实际上是一个容器适配器它提供了对底层容器的堆操作其可选的底层容器包括等但注意不能使用不支持随机访问迭代器需要能够通过索引或迭代器直接访问任意元素默认使用在中默认是一个最大堆队列的顶部元素总是具有最大的值堆是一个特别完全二叉树的结构即满足父结点的键值总是大于或者小于它的子节点的完全二叉树父节点的值恒小于等于子节点的值称为最小堆父节点的值恒大于等于子节点的值此堆称为最大堆检查队列是否为空返回队列中的元素数量返回队列顶部的元素不删除它向队列添加一个元素移除队列顶部的元素优先级判断重载法一运算符重载不改变语义按默认大的在堆顶法二重写仿函数返回代表后者优先级高放在堆顶此处为年龄小的优先级高其他",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-03-15 12:00:00",postMainColor:""}</script><noscript><style type=text/css>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,c={})=>new Promise((t,e)=>{let a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(c).forEach(e=>{a.setAttribute(e,c[e])}),document.head.appendChild(a)}),e.getCSS=(o,c=!1)=>new Promise((t,e)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,c&&(a.id=c),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};var e=saveToLocal.get("theme"),t=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,o=window.matchMedia("(prefers-color-scheme: no-preference)").matches,c=!t&&!a&&!o,t=(void 0===e?(a?activateLightMode():t?activateDarkMode():(o||c)&&((a=(new Date).getHours())<=6||18<=a?activateDarkMode:activateLightMode)(),window.matchMedia("(prefers-color-scheme: dark)").addListener(e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode:activateLightMode)()})):("light"===e?activateLightMode:activateDarkMode)(),saveToLocal.get("aside-status"));void 0!==t&&("hide"===t?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel=stylesheet href=/static/css/custom.css media=defer onload='this.media="all"'><link rel=stylesheet href=https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css media=defer onload='this.media="all"'><link rel=stylesheet href=https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css media=defer onload='this.media="all"'><script src=https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js></script><meta name=generator content="Hexo 7.3.0"></head><body data-type=anzhiyu><div id=web_bg></div><div id=an_music_bg></div><div id=loading-box onclick=document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)><div class=loading-bg><img class="loading-img nolazyload" alt=加载头像 src=https://assets.blog.x1ang.com/config/keqing.webp><div class=loading-image-dot></div></div></div><script>let preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()}),setTimeout(function(){preloader.endLoading()},1e4),document.addEventListener("pjax:send",()=>{preloader.initLoading()}),document.addEventListener("pjax:complete",()=>{preloader.endLoading()})</script><link rel=stylesheet href=https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css><script async=async src=https://cdn.cbd.int/pace-js@1.2.4/pace.min.js data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class=post id=body-wrap><header class=post-bg id=page-header><nav id=nav><div id=nav-group><span id=blog_name><a id=site-name href=/ accesskey=h><div class=title>x1ang</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id=he-plugin-simple></div><script>var WIDGET={CONFIG:{modules:"0124",background:"2",tmpColor:"FFFFFF",tmpSize:"16",cityColor:"FFFFFF",citySize:"16",aqiColor:"E8D87B",aqiSize:"16",weatherIconSize:"24",alertIconSize:"18",padding:"10px 10px 10px 10px",shadow:"0",language:"auto",borderRadius:"20",fixed:"true",vertical:"top",horizontal:"left",left:"20",top:"7.1",key:"df245676fb434a0691ead1c63341cd94"}}</script><link rel=stylesheet href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class=mask-name-container><div id=name-container><a id=page-name href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id=menus><div class=menus_items><div class=menus_item><a class=site-page href=javascript:void(0);><span>文章</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/archives/ ><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style=font-size:.9em></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/categories/ ><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style=font-size:.9em></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/tags/ ><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style=font-size:.9em></i><span> 标签</span></a></li></ul></div><div class=menus_item><a class="site-page faa-parent animated-hover" href=/album/ ><span>相册</span></a></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>娱乐</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9140460034&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style=font-size:.9em></i><span> 音乐厅</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/animations/ ><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style=font-size:.9em></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/games/ ><i class="fas fa-gamepad faa-tada"></i><span> 游戏集</span></a></li></ul></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>友链</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/link/ ><i class="anzhiyufont anzhiyu-icon-link faa-tada" style=font-size:.9em></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/comments/ ><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style=font-size:.9em></i><span> 留言板</span></a></li></ul></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>关于</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/website/ ><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style=font-size:.9em></i><span> 关于网站</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/myself/ ><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style=font-size:.9em></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/equipment/ ><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style=font-size:.9em></i><span> 我的装备</span></a></li></ul></div></div></div><div id=nav-right><div class="nav-button only-home" id=travellings_button title=随机前往一个开往项目网站><a class=site-page onclick=anzhiyu.totraveling() title=随机前往一个开往项目网站 href=javascript:void(0); rel="external nofollow" data-pjax-state=external><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class=nav-button id=randomPost_button><a class=site-page onclick=toRandomPost() title=随机前往一个文章 href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class=nav-button id=search-button><a class="site-page social-icon search" href=javascript:void(0); title=搜索🔍 accesskey=s><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id=center-console type=checkbox><label class=widget for=center-console title=中控台 onclick=anzhiyu.switchConsole()><i class=left></i><i class="widget center"></i><i class="widget right"></i></label><div id=console><div class=console-card-group-reward><ul class="reward-all console-card"><li class=reward-item><a href=https://assets.blog.x1ang.com/config/wechat.webp target=_blank><img class=post-qr-code-img alt=微信 src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/wechat.webp></a><div class=post-qr-code-desc>微信</div></li><li class=reward-item><a href=https://assets.blog.x1ang.com/config/alipay.webp target=_blank><img class=post-qr-code-img alt=支付宝 src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/alipay.webp></a><div class=post-qr-code-desc>支付宝</div></li></ul></div><div class=console-card-group><div class=console-card-group-left><div class=console-card id=card-newest-comments><div class=card-content><div class=author-content-item-tips>互动</div><span class=author-content-item-title>最新评论</span></div><div class=aside-list><span>正在加载中...</span></div></div></div><div class=console-card-group-right><div class="console-card tags"><div class=card-content><div class=author-content-item-tips>兴趣点</div><span class=author-content-item-title>寻找你感兴趣的领域</span><div class=card-tags><div class=item-headline></div><div class=card-tag-cloud><a href=/tags/C/ style=font-size:1.05rem>C++<sup>1</sup></a><a href=/tags/GaN%E7%94%B5%E6%BA%90/ style=font-size:1.05rem>GaN电源<sup>1</sup></a><a href=/tags/%E5%8D%9A%E5%AE%A2/ style=font-size:1.05rem>博客<sup>1</sup></a><a href=/tags/%E5%BD%97%E6%98%9F/ style=font-size:1.05rem>彗星<sup>1</sup></a><a href=/tags/%E6%8F%92%E4%BB%B6/ style=font-size:1.05rem>插件<sup>1</sup></a><a href=/tags/%E9%A3%8E%E5%85%89/ style=font-size:1.05rem>风光<sup>1</sup></a><a href=/tags/%E9%AD%94%E6%94%B9/ style=font-size:1.05rem>魔改<sup>1</sup></a></div></div><hr></div></div><div class="console-card history"><div class=item-headline><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div></div></div></div><div class=button-group><div class=console-btn-item><a class=darkmode_switchbutton title=显示模式切换 href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class=console-btn-item id=consoleHideAside onclick=anzhiyu.hideAsideBtn() title=边栏显示控制><a class=asideSwitch><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id=consoleCommentBarrage onclick=anzhiyu.switchCommentBarrage() title=热评开关><a class=commentBarrage><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class=console-btn-item id=consoleMusic onclick=anzhiyu.musicToggle() title=音乐开关><a class=music-switch><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class=console-mask onclick=anzhiyu.hideConsole() href=javascript:void(0);></div></div><div class=nav-button id=nav-totop><a class=totopbtn href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id=percent onclick=anzhiyu.scrollToDest(0,500)>0</span></a></div><div id=toggle-menu><a class=site-page href=javascript:void(0); title=切换><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id=post-info><div id=post-firstinfo><div class=meta-firstline><a class=post-meta-original>原创</a><span class=post-meta-categories><span class=post-meta-separator></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class=post-meta-categories href=/categories/%E5%A4%A7%E5%86%92%E9%99%A9/ itemprop=url>大冒险</a></span><span class="article-meta tags"><a class=article-meta__tags href=/tags/C/ tabindex=-1 itemprop=url> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class=post-title itemprop="name headline">C++查漏补缺</h1><div id=post-meta><div class=meta-firstline><span class=post-meta-date><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class=post-meta-label>发表于</span><time class=post-meta-date-created itemprop="dateCreated datePublished" datetime=2025-03-15T04:00:00.000Z title="发表于 2025-03-15 12:00:00">2025-03-15</time><span class=post-meta-separator></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class=post-meta-label>更新于</span><time class=post-meta-date-updated itemprop="dateCreated datePublished" datetime=2025-03-15T04:00:00.000Z title="更新于 2025-03-15 12:00:00">2025-03-15</time></span></div><div class=meta-secondline><span class=post-meta-separator></span><span class=post-meta-wordcount><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title=文章字数></i><span class=post-meta-label title=文章字数>字数总计:</span><span class=word-count title=文章字数>8.2k</span><span class=post-meta-separator></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title=阅读时长></i><span class=post-meta-label title=阅读时长>阅读时长:</span><span>27分钟</span></span><span class=post-meta-separator></span><span class=post-meta-pv-cv id="" data-flag-title=C++查漏补缺><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class=post-meta-label title=阅读量>阅读量:</span><span id=busuanzi_value_page_pv><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class=post-meta-separator> </span><span class=post-meta-position title=作者IP属地为海口><i class="anzhiyufont anzhiyu-icon-location-dot"></i>海口</span><span class=post-meta-separator></span><span class=post-meta-commentcount><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class=post-meta-label>评论数:</span><a href=/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/#post-comment tabindex=-1><span id=twikoo-count><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class=waves-svg xmlns=http://www.w3.org/2000/svg xlink=http://www.w3.org/1999/xlink viewBox="0 24 150 28" preserveAspectRatio=none shape-rendering=auto><defs><path id=gentle-wave d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class=parallax><use href=#gentle-wave x=48 y=0></use><use href=#gentle-wave x=48 y=3></use><use href=#gentle-wave x=48 y=5></use><use href=#gentle-wave x=48 y=7></use></g></svg></section><div id=post-top-cover><img class=nolazyload id=post-top-bg src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://assets.blog.x1ang.com/default_cover_3.webp?_r_=cac6baa4-5d41-2724-b865-44d3c48e3c49"></div></header><main id=blog-container><div class=layout id=content-inner><div id=post><article class=post-content id=article-container itemscope itemtype=https://x1ang.com/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ ><header><a class=post-meta-categories href=/categories/%E5%A4%A7%E5%86%92%E9%99%A9/ itemprop=url>大冒险</a><a href=/tags/C/ tabindex=-1 itemprop=url>C++</a><h1 id=CrawlerTitle itemprop="name headline">C++查漏补缺</h1><span itemprop=author itemscope itemtype=http://schema.org/Person>x1ang</span><time itemprop="dateCreated datePublished" datetime=2025-03-15T04:00:00.000Z title="发表于 2025-03-15 12:00:00">2025-03-15</time><time itemprop="dateCreated datePublished" datetime=2025-03-15T04:00:00.000Z title="更新于 2025-03-15 12:00:00">2025-03-15</time></header><h1 id=一、吸佳佳查漏补缺><a href=#一、吸佳佳查漏补缺 class=headerlink title=一、吸佳佳查漏补缺></a>一、吸佳佳查漏补缺</h1><h2 id=编译器><a href=#编译器 class=headerlink title=编译器></a>编译器</h2><h2 id=c-11><a href=#c-11 class=headerlink title=c++11></a>c++11</h2><h3 id=移动语义><a href=#移动语义 class=headerlink title=移动语义></a>移动语义</h3><p>它允许将一个对象的<strong>所有权</strong>从一个对象<strong>转移</strong>到另一个对象，而不需要进行数据的拷贝和搬迁。使程序在内存管理方面更加高效。</p><p>移动语义是通过右值引用来实现的，右值引用的语法是 <code>&amp;&amp;</code>，这是一种新的引用类型，用于表示<strong>即将销毁的对象</strong>。</p><p>但需要注意，使用<code>move</code>后原对象的状态是不确定的，不应再对其进行操作。</p><p>右值引用只能绑定到一个右值，不能绑定到一个左值。但是可以使用 <code>move</code> 函数将一个<strong>左值强制转换</strong>为右值引用，从而允许我们使用移动语义。</p><h5 id=左值和右值><a href=#左值和右值 class=headerlink title=左值和右值></a>左值和右值</h5><ul><li>左值表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。（可寻址的对象）</li><li>右值则使用排除法来定义。是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</li></ul><h2 id=内存管理><a href=#内存管理 class=headerlink title=内存管理></a>内存管理</h2><h4 id=内存分区><a href=#内存分区 class=headerlink title=内存分区></a>内存分区</h4><p><strong>堆区</strong>：容量大于栈，由程序员管理，手动申请手动释放，程序中动态分配的内存在此区域</p><p><strong>栈区</strong>：由系统进行管理的区域。主要存放<strong>函数的参数</strong>以及<strong>局部变量</strong>。栈区的大小可以在编译器中由用户自行设定。</p><p><strong>文字常量区</strong>：储存常量字符串，文字常量区的内存是<strong>只读</strong>的。</p><p><strong>代码区</strong>：存放函数体的二进制代码。</p><p><strong>全局\静态区</strong>：储存<strong>全局变量</strong>和静态变量以及<strong>除了字符串</strong>以外的<strong>其他类型常量</strong>，其中<strong>被初始化</strong>的和<strong>未被初始化</strong>的又可以分为<strong>数据段</strong>和<strong>BSS</strong>。</p><h4 id=智能指针><a href=#智能指针 class=headerlink title=智能指针></a>智能指针</h4><p>将分配的动态内存都交由有<strong>生命周期的对象</strong>来处理，那么在对象过期时，让它的析构函数删除指向的内存。</p><p>C++98 提供了 <code>auto_ptr</code> 模板的解决方案（<strong>已弃用</strong>）</p><p>C++11增加<code>unique_ptr</code>、<code>shared_ptr</code> 和<code>weak_ptr</code></p><h5 id=auto-ptr（已弃用）><a href=#auto-ptr（已弃用） class=headerlink title=auto_ptr（已弃用）></a>auto_ptr（<strong>已弃用</strong>）</h5><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span><span class=string>&lt;memory&gt;</span></span></span><br><span class=line></span><br><span class=line><span class=function>auto_ptr&lt;Test&gt; <span class=title>test</span><span class=params>(<span class=keyword>new</span> Test)</span></span>;<span class=comment>// auto_ptr中重载了*和-&gt;，可以直接像普通指针一样使用</span></span><br></pre></td></tr></table></figure><p>auto_ptr 主要有三大问题：</p><p>复制和赋值会改变资源的所有权，不符合人的直觉。</p><p>在 STL 容器中使用<code>auto_ptr</code>存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。</p><p>不支持对象数组的操作</p><h5 id=unique-ptr><a href=#unique-ptr class=headerlink title=unique_ptr></a>unique_ptr</h5><p>unique_ptr 和 auto_ptr用法几乎一样</p><h2 id=1、关键字><a href=#1、关键字 class=headerlink title=1、关键字></a>1、关键字</h2><h5 id=inline><a href=#inline class=headerlink title=inline></a>inline</h5><p>内联函数<code>inline</code>（有时称作编译时期展开函数）是一种编程语言结构，用来<strong>建议</strong>编译器将指定的函数体插入并取代每一处调用该函数的地方，从而节省了每次调用函数带来的额外时间开支。类内部的函数一般会自动内联。</p><p>定义内联函数是一个空间代价换时间的操作，在现代处理器上，通常代码越小执行越快，因为指令缓存利用率高。</p><p>通常，编译器比程序设计者更清楚对于一个特定的函数是否合适进行内联扩展；一些情况下，对于程序员指定的某些内联函数，编译器可能更倾向于不使用内联甚至根本无法完成内联。</p><p><strong>c++17</strong>完全改变了<code>inline</code>的定义，从原来的优先内联改为<strong>容许多次定义</strong>，被<code>inline</code>修饰的函数会被定义成<strong>弱函数</strong>，会被其他普通函数覆盖。对于原本内联的功能<strong>完全交给编译器</strong>优化，较新的编译器启用优化模式，不管对于什么版本的c++标准都会自动决定函数的内联。</p><h5 id=new与malloc><a href=#new与malloc class=headerlink title=new与malloc></a>new与malloc</h5><p>malloc是C语言中的函数，而new是C++中的操作符</p><p>我的理解：new是malloc的超集，malloc只负责内存的分配，而new会确保了对象在创建时已经正确初始化。</p><ul><li>malloc申请之后返回的类型是void*，而new返回的指针带有类型。</li><li>malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数。</li></ul><h5 id=const-与-constexpr><a href=#const-与-constexpr class=headerlink title="const 与 constexpr"></a>const 与 constexpr</h5><p><code>const</code> 修饰的变量只能读取，一旦被初始化就无法修改，可以在运行期间计算得出</p><p><code>constexpr</code> 修饰的对象必须是常量，即必须是编译期间可以计算出来的</p><p><code>constexpr</code>是C++11引入的，一方面是为了引入更多的编译时计算能力，另一方面也是解决 C++98 的 <code>const</code> 的双重语义问题。</p><p>在 C 里面，<code>const</code> 很明确只有<strong>「只读」</strong>一个语义，不会混淆。C++ 在此基础上增加了<strong>「常量」</strong>语义，也由 <code>const</code> 关键字来承担，引出来一些奇怪的问题。C++11 把<strong>「常量」</strong>语义拆出来，交给新引入的 <code>constexpr</code> 关键字。</p><p>例如在 C++ 标准中，只允许使用常量初始化数组，如<code>cin &gt;&gt; n; int arr2[n];</code> 其中 n 在程序运行中才确定，不属于常量。尽管在 C 语言的 C99 标准中支持了变长数组，使得很多编译器（如 GCC、Clang、G++）允许这种写法，但它是编译器扩展的特性，不符合 C++ 的标准行为。此时用 <code>const</code> 修饰的变量初始化数组可能会出现未知的问题。</p><p>注意：<code>constexpr</code> 并不强制要求函数在每个使用时都必须在编译时计算结果。它只是表示<strong>该函数可以在编译时求值</strong>，如果条件允许的话。</p><h5 id=volatile><a href=#volatile class=headerlink title=volatile></a>volatile</h5><p><code>volatile</code> 关键字是一种类型修饰符，用它声明的变量or对象表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声</p><p>明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。（<strong>被<code>volatile</code>修饰的变量或对象，不会被存入寄存器中，总是从内存中读取</strong>）</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=type>void</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=type>int</span> i = <span class=number>10</span>;</span><br><span class=line>    <span class=type>int</span> a = i;</span><br><span class=line></span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>&quot;i = %d&quot;</span>, a);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 下面汇编语句的作用就是改变内存中i的值为32，但是又不让编译器知道</span></span><br><span class=line>    __asm &#123;</span><br><span class=line>        mov dword ptr [ebp<span class=number>-4</span>], <span class=number>20</span>h</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=type>int</span> b = i;</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>&quot;i = %d&quot;</span>, b);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>i = <span class=number>10</span></span><br><span class=line>i = <span class=number>32</span></span><br></pre></td></tr></table></figure><h4 id=1-1、储存类><a href=#1-1、储存类 class=headerlink title=1.1、储存类></a>1.1、储存类</h4><p>用于定义 C++ 程序中变量/函数的范围（可见性）和生命周期。</p><h5 id=mutable><a href=#mutable class=headerlink title=mutable></a>mutable</h5><p><code>mutable</code> 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 <code>const</code> 的。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Example</span> &#123;</span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line>    <span class=function><span class=type>int</span> <span class=title>get_value</span><span class=params>()</span> <span class=type>const</span> </span>&#123;</span><br><span class=line>        <span class=keyword>return</span> value_; <span class=comment>// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class=line>    &#125;</span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>set_value</span><span class=params>(<span class=type>int</span> value)</span> <span class=type>const</span> </span>&#123;</span><br><span class=line>        value_ = value; <span class=comment>// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class=line>    &#125;</span><br><span class=line><span class=keyword>private</span>:</span><br><span class=line>    <span class=keyword>mutable</span> <span class=type>int</span> value_;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><h5 id=extern><a href=#extern class=headerlink title=extern></a>extern</h5><p>用于声明具有外部链接的变量或函数，它们可以在多个文件之间共享。默认情况下，全局变量和函数具有 <code>extern</code> 存储类。在一个文件中使用<code>extern</code>声明另一个文件中定义的全局变量或函数，可以实现<strong>跨文件共享</strong>。</p><h5 id=thread-local><a href=#thread-local class=headerlink title=thread_local></a>thread_local</h5><p>用于定义具有<strong>线程局部存储期</strong>的变量，每个线程都有自己的独立副本。线程局部变量的生命周期与线程的生命周期相同。</p><h5 id=static><a href=#static class=headerlink title=static></a>static</h5><p>用于定义静态变量或函数。静态变量或函数的性质：</p><p><strong>存储期</strong>：使用 <code>static</code> 修饰的变量在程序整个运行期间都存在，这意味着内存空间在程序启动时分配，直到程序结束才释放。现代编译器和链接器能对未被使用的静态变量进行优化。（<code>const</code>变量默认具有<code>static</code>存储期）</p><p><strong>链接性</strong>：<code>static</code> 修饰的变量或函数具有内部链接，只能在本文件中访问，避免了全局命名冲突。如果在头文件定义静态函数，被多个cpp调用，会生成多份函数代码。</p><h2 id=2、Lambda函数与表达><a href=#2、Lambda函数与表达 class=headerlink title=2、Lambda函数与表达></a>2、Lambda函数与表达</h2><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[capture](parameters)-&gt;return_type&#123;body&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>[]      <span class=comment>// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class=line>[x, &amp;y] <span class=comment>// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class=line>[&amp;]     <span class=comment>// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class=line>[=]     <span class=comment>// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class=line>[&amp;, x]  <span class=comment>// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class=line>[=, &amp;z] <span class=comment>// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[<span class=keyword>this</span>]() &#123; <span class=keyword>this</span>-&gt;<span class=built_in>someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure><h2 id=3、随机数><a href=#3、随机数 class=headerlink title=3、随机数></a>3、随机数</h2><h5 id=rand><a href=#rand class=headerlink title=rand></a>rand</h5><p><code>rand()</code> 函数包含在头文件 <code>&lt;cstdlib&gt;</code> 中，调用后会随机（伪随机）返回一个值域在0到<code>RAND_MAX</code>（保证均匀分布）的 <code>int</code> 变量</p><p>由于该函数使用的是<strong>线性同余方程</strong>生成随机数，所以<strong>循环节</strong>并不长，RAND_MAX一般为 <code>0x7fff</code>，即 <strong>32767</strong>（2^15−1）</p><p>在使用前需要先通过 <code>srand()</code> 函数设定随机数种子，通常采用时间作为种子。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdlib.h&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;ctime&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;chrono&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std; </span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>Rand</span><span class=params>( <span class=type>int</span> x, <span class=type>int</span> y )</span>	<span class=comment>/* 获取一个在 [x,y] 范围中的随机数 */</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>	<span class=keyword>return</span> <span class=built_in>rand</span>() % (y - x + <span class=number>1</span>) + x;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123; </span><br><span class=line>        <span class=built_in>srand</span>((<span class=type>unsigned</span>)<span class=built_in>time</span>(<span class=literal>NULL</span>));<span class=comment>// time(NULL) 是算法竞赛中最常用的种子之一,包含在头文件 &lt;ctime&gt; 中,缺点：一秒一变</span></span><br><span class=line>    	<span class=built_in>srand</span>(chrono::system_clock::<span class=built_in>now</span>().<span class=built_in>time_since_epoch</span>().<span class=built_in>count</span>());<span class=comment>//精度可以达到纳秒包含在头文件chrono中</span></span><br><span class=line>    </span><br><span class=line>        <span class=keyword>for</span>(<span class=type>int</span> i = <span class=number>0</span>; i &lt; <span class=number>10</span>;i++ ) </span><br><span class=line>        &#123;</span><br><span class=line>            cout &lt;&lt; <span class=built_in>Rand</span>(<span class=number>1</span>,<span class=number>100</span>) &lt;&lt; endl; </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=random-device><a href=#random-device class=headerlink title=random_device></a>random_device</h5><p><code>std::random_device</code> 是一种随机数生成器类型，在头文件 <code>&lt;random&gt;</code> 中，如果在 Linux 下调用会通过系统提供的一个系统噪音收集器来获取真随机数，在 Windows 下就会利用很多数据来计算熵，可以近似认为是真随机的。值域在 <strong>0 - 2^32 - 1</strong> 也就是 <code>unsigned int</code> 的值域范围</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;random&gt;</span></span></span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line></span><br><span class=line>  random_device rd;</span><br><span class=line></span><br><span class=line>  cout &lt;&lt; <span class=string>&quot;Random number: &quot;</span> &lt;&lt; <span class=built_in>rd</span>() &lt;&lt; endl;</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=mt19937><a href=#mt19937 class=headerlink title=mt19937></a>mt19937</h5><p>这个奇怪的名字来源于这个生成随机数的算法 <strong>Mersenne twister（梅森旋转算法）</strong>，至于其中的 1993719937 则是代表它生成的随机数的周期可以到达 <strong>2^19937−1</strong> 的惊人数量级，相比起 <code>rand()</code> 确实可以避免很多问题，而且 <code>mt19937</code> 几乎是最快的伪随机数生成器，效率非常高</p><p><code>std::mt19937</code> 是一个随机数生成器类型，在头文件 <code>&lt;random&gt;</code> 中，调用时其会返回一个 <code>unsigned int</code>，值域也在 <strong>0 - 2^32 - 1</strong>。</p><p>如果需要更大的值域范围可以使用 <code>std::mt19937_64</code>，唯一的区别就是返回值变成了一个 <code>unsigned long long</code></p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;random&gt;</span></span></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment> * std::random_device rd;</span></span><br><span class=line><span class=comment> * std::mt19937 Rnd(rd());</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line>	<span class=function>std::mt19937 <span class=title>Rnd</span><span class=params>( std::random_device &#123;&#125; () )</span></span>; <span class=comment>// 这样写等价于上面注释掉的写法，种子为 random_device</span></span><br><span class=line>	std::cout &lt;&lt; <span class=built_in>Rnd</span>() &lt;&lt; std::endl;</span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=shuffle><a href=#shuffle class=headerlink title=shuffle></a>shuffle</h5><p><code>std::shuffle()</code> 自 C++11 被引入，用于替代 <code>random_shuffle()</code>，在 <code>&lt;algorithm&gt;</code> 头文件中，它必须传入三个参数，前两个一样是容器的头尾迭代器，最后一个参数是随机数生成器</p><p>随机数生成器可以是 <code>std::random_device</code>，可以是 <code>std::mt19937</code>，也可以是 <code>std::default_random_engine</code>（同样 C++11 引入，用于替代 <code>rand()</code> 的随机数生成器，但是性能不及 <code>mt19937</code>，所以还是推荐 <code>mt19937</code>）</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;algorithm&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;random&gt;</span></span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>	<span class=function>std::mt19937 <span class=title>Rnd</span><span class=params>( std::random_device &#123;&#125; () )</span></span>;</span><br><span class=line>	<span class=function>std::vector&lt;<span class=type>int</span>&gt; <span class=title>a</span><span class=params>( &#123; <span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>, <span class=number>5</span> &#125; )</span></span>;</span><br><span class=line>	std::<span class=built_in>shuffle</span>( a.<span class=built_in>begin</span>(), a.<span class=built_in>end</span>(), Rnd );</span><br><span class=line>	<span class=keyword>for</span> ( <span class=keyword>auto</span> x : a ) </span><br><span class=line>    &#123;</span><br><span class=line>		std::cout &lt;&lt; x &lt;&lt; <span class=string>&#x27; &#x27;</span>; <span class=comment>// 一种可能的输出：3 2 5 1 4     </span></span><br><span class=line>    &#125;</span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=4、模板><a href=#4、模板 class=headerlink title=4、模板></a>4、模板</h2><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p><p>例如vector容器只有一个单一的定义，而形如<code>vector &lt;int&gt;</code>或 <code>vector &lt;string&gt;</code>等不同的类型的元素即是通过模板实现的。</p><h5 id=函数模板><a href=#函数模板 class=headerlink title=函数模板></a>函数模板</h5><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>template</span> &lt;<span class=keyword>typename</span> type&gt; <span class=comment>// 在这里，type是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</span></span><br><span class=line>ret-type func-<span class=built_in>name</span>(parameter list) </span><br><span class=line>&#123;   </span><br><span class=line>	<span class=comment>// 函数的主体 </span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=类模板><a href=#类模板 class=headerlink title=类模板></a>类模板</h5><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>template</span> &lt;<span class=keyword>class</span> <span class="title class_">type</span>&gt; <span class=comment>// type可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">class</span>-name </span><br><span class=line>&#123;</span><br><span class=line>	<span class=comment>// 类的主体</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h6 id=实例><a href=#实例 class=headerlink title=实例></a>实例</h6><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;iostream&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;string&gt;</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;vector&gt;</span></span></span><br><span class=line> </span><br><span class=line><span class=keyword>using</span> <span class=keyword>namespace</span> std;</span><br><span class=line></span><br><span class=line><span class=comment>// 函数模板的实例，返回两个数中的最大值，输入可以是int、double、string类型</span></span><br><span class=line><span class=keyword>template</span> &lt;<span class=keyword>typename</span> T&gt;</span><br><span class=line><span class=function><span class=keyword>inline</span> T <span class=type>const</span>&amp; <span class=title>Max</span> <span class=params>(T <span class=type>const</span>&amp; a, T <span class=type>const</span>&amp; b)</span> </span></span><br><span class=line><span class=function></span>&#123; </span><br><span class=line>    <span class=keyword>return</span> a &lt; b ? b:a; </span><br><span class=line>&#125; </span><br><span class=line></span><br><span class=line><span class=comment>// 类模板实例，Stack&lt;&gt;，实现了泛型方法来对元素进行入栈出栈操作</span></span><br><span class=line><span class=keyword>template</span> &lt;<span class=keyword>class</span> <span class="title class_">T</span>&gt;</span><br><span class=line><span class=keyword>class</span> <span class="title class_">Stack</span> &#123; </span><br><span class=line>  <span class=keyword>private</span>: </span><br><span class=line>    vector&lt;T&gt; elems;          <span class=comment>// 元素 </span></span><br><span class=line> </span><br><span class=line>  <span class=keyword>public</span>: </span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>push</span><span class=params>(T <span class=type>const</span>&amp;)</span></span>;  	  <span class=comment>// 入栈</span></span><br><span class=line>    <span class=function><span class=type>void</span> <span class=title>pop</span><span class=params>()</span></span>;               <span class=comment>// 出栈</span></span><br><span class=line>    <span class=function>T <span class=title>top</span><span class=params>()</span> <span class=type>const</span></span>;            <span class=comment>// 返回栈顶元素</span></span><br><span class=line>    <span class=function><span class=type>bool</span> <span class=title>empty</span><span class=params>()</span> <span class=type>const</span></span>&#123;       <span class=comment>// 如果为空则返回真。</span></span><br><span class=line>        <span class=keyword>return</span> elems.<span class=built_in>empty</span>(); </span><br><span class=line>    &#125; </span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>template</span> &lt;<span class=keyword>class</span> <span class="title class_">T</span>&gt;</span><br><span class=line><span class=type>void</span> Stack&lt;T&gt;::<span class=built_in>push</span> (T <span class=type>const</span>&amp; elem) </span><br><span class=line>&#123; </span><br><span class=line>    <span class=comment>// 追加传入元素的副本</span></span><br><span class=line>    elems.<span class=built_in>push_back</span>(elem);    </span><br><span class=line>&#125; </span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>	......省去其余函数实现</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span></span><br><span class=line><span class=function></span>&#123; </span><br><span class=line>    <span class=type>int</span> i = <span class=number>20</span>, j = <span class=number>30</span>;</span><br><span class=line>    string s1 = <span class=string>&quot;hello&quot;</span>, s2 = <span class=string>&quot;world&quot;</span>;</span><br><span class=line>    </span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Max(i, j): &quot;</span> &lt;&lt; <span class=built_in>Max</span>(i, j) &lt;&lt; endl; </span><br><span class=line>    cout &lt;&lt; <span class=string>&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class=built_in>Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class=line>    </span><br><span class=line>    </span><br><span class=line>    Stack&lt;<span class=type>int</span>&gt;         intStack; <span class=comment>// int 类型的栈 </span></span><br><span class=line>    Stack&lt;string&gt;   stringStack; <span class=comment>// string 类型的栈 </span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 操作 int 类型的栈 </span></span><br><span class=line>    intStack.<span class=built_in>push</span>(<span class=number>7</span>); </span><br><span class=line>    <span class=comment>// 操作 string 类型的栈 </span></span><br><span class=line>    stringStack.<span class=built_in>push</span>(<span class=string>&quot;hello&quot;</span>); </span><br><span class=line></span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=6、数据结构><a href=#6、数据结构 class=headerlink title=6、数据结构></a>6、数据结构</h2><h5 id=链表（Linked-List）><a href=#链表（Linked-List） class=headerlink title="链表（Linked List）"></a><strong>链表（Linked List）</strong></h5><p>链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。</p><ul><li>动态调整大小，不需要提前定义容量。</li><li>插入和删除操作效率高，时间复杂度为 O(1)（在链表头部或尾部操作）。</li><li>线性查找，时间复杂度为 O(n)。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">Node</span> &#123;</span><br><span class=line>    <span class=type>int</span> data;</span><br><span class=line>    Node* next;</span><br><span class=line>&#125;;</span><br><span class=line>Node* head = <span class=literal>nullptr</span>;</span><br><span class=line>Node* newNode = <span class=keyword>new</span> Node&#123;<span class=number>10</span>, <span class=literal>nullptr</span>&#125;;</span><br><span class=line>head = newNode; <span class=comment>// 插入新节点</span></span><br></pre></td></tr></table></figure><h5 id=栈（Stack）><a href=#栈（Stack） class=headerlink title=栈（Stack）></a><strong>栈（Stack）</strong></h5><p>栈是一种后进先出（LIFO, Last In First Out）的数据结构，常用于递归、深度优先搜索等场景。</p><ul><li>只允许在栈顶进行插入和删除操作。</li><li>时间复杂度为 O(1)。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>stack&lt;<span class=type>int</span>&gt; s;</span><br><span class=line>s.<span class=built_in>push</span>(<span class=number>1</span>);</span><br><span class=line>s.<span class=built_in>push</span>(<span class=number>2</span>);</span><br><span class=line>cout &lt;&lt; s.<span class=built_in>top</span>(); <span class=comment>// 输出 2</span></span><br><span class=line>s.<span class=built_in>pop</span>();</span><br></pre></td></tr></table></figure><h5 id=队列（Queue）><a href=#队列（Queue） class=headerlink title=队列（Queue）></a><strong>队列（Queue）</strong></h5><p>队列是一种先进先出（FIFO, First In First Out）的数据结构，常用于广度优先搜索、任务调度等场景。</p><ul><li>插入操作在队尾进行，删除操作在队头进行。</li><li>时间复杂度为 O(1)。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>queue&lt;<span class=type>int</span>&gt; q;</span><br><span class=line>q.<span class=built_in>push</span>(<span class=number>1</span>);</span><br><span class=line>q.<span class=built_in>push</span>(<span class=number>2</span>);</span><br><span class=line>cout &lt;&lt; q.<span class=built_in>front</span>(); <span class=comment>// 输出 1</span></span><br><span class=line>q.<span class=built_in>pop</span>();</span><br></pre></td></tr></table></figure><h5 id=双端队列（Deque）><a href=#双端队列（Deque） class=headerlink title=双端队列（Deque）></a><strong>双端队列（Deque）</strong></h5><p>双端队列允许在两端进行插入和删除操作，是栈和队列的结合体。</p><ul><li>允许在两端进行插入和删除。</li><li>时间复杂度为 O(1)。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>deque&lt;<span class=type>int</span>&gt; dq;</span><br><span class=line>dq.<span class=built_in>push_back</span>(<span class=number>1</span>);</span><br><span class=line>dq.<span class=built_in>push_front</span>(<span class=number>2</span>);</span><br><span class=line>cout &lt;&lt; dq.<span class=built_in>front</span>(); <span class=comment>// 输出 2</span></span><br><span class=line>dq.<span class=built_in>pop_front</span>();</span><br></pre></td></tr></table></figure><h5 id=哈希表（Hash-Table）><a href=#哈希表（Hash-Table） class=headerlink title="哈希表（Hash Table）"></a><strong>哈希表（Hash Table）</strong></h5><p>将key使用哈希函数计算，结果取n的模，然后用一个大小为n的链表数组记录数据，在取模结果的位置上增加一个存放了key和value的链表节点。查找同理，计算哈希值-取模-找到链表数组中位置-遍历链表。</p><p>当链表长度过长，触发扩容机制。数组长度n翻倍，重新计算所有数据的位置，扩容时间复杂度O（NlogN）</p><p>哈希操作只是在使用上趋近于O（1）的水平</p><p>哈希表是一种通过键值对存储数据的数据结构，支持快速查找、插入和删除操作。C++ 中的 <code>unordered_map</code> 是哈希表的实现。</p><ul><li>使用哈希函数快速定位元素，时间复杂度为 O(1)。</li><li>不保证元素的顺序。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>unordered_map&lt;string, <span class=type>int</span>&gt; hashTable;</span><br><span class=line>hashTable[<span class=string>&quot;apple&quot;</span>] = <span class=number>10</span>;</span><br><span class=line>cout &lt;&lt; hashTable[<span class=string>&quot;apple&quot;</span>]; <span class=comment>// 输出 10</span></span><br></pre></td></tr></table></figure><h5 id=哈希表的应用><a href=#哈希表的应用 class=headerlink title=哈希表的应用></a>哈希表的应用</h5><h6 id=布隆过滤器><a href=#布隆过滤器 class=headerlink title=布隆过滤器></a>布隆过滤器</h6><p>将每个数据通过k个哈希函数再取m的模，计算出k个特征值，在大小m位的位图中记录这k个特征值的位置</p><p>其中所需位图大小需要样本量n和允许的失误率p计算，哈希函数个数也就是特征值个数需要m和n计算</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=吸佳佳查漏补缺.assets\image-20250407175948599.png alt=image-20250407175948599></p><h6 id=一致性哈希><a href=#一致性哈希 class=headerlink title=一致性哈希></a>一致性哈希</h6><p>假设三台服务器用于存储数据，如何做到负载均衡？</p><p>将某哈希算法的哈希空间虚拟成一个圆环，所有的数据计算出来的哈希值都能映射在这个哈希环上。</p><p>对于每台服务器，按照负载能力分配不同数量的节点，用同样的哈希算法计算每个节点的哈希值也映射到哈希环上，节点数量较大时能近似认为是均匀分布的，节点之间的数据由顺时针方向上的节点对应的服务器管理。</p><p>这样由于哈希值分布的均匀性和离散性，可以做到负载均衡，同时如果需要新增服务器或者减少服务器，可以直接新增或者删除环上的节点，移动数据也只需要移动被影响的节点对应的数据。</p><h5 id=映射（Map）><a href=#映射（Map） class=headerlink title=映射（Map）></a><strong>映射（Map）</strong></h5><p><code>map</code> 是一种有序的键值对容器，底层实现是红黑树。与 <code>unordered_map</code> 不同，它保证键的顺序，查找、插入和删除的时间复杂度为 O(log n)。</p><ul><li>保证元素按键的顺序排列。</li><li>使用二叉搜索树实现。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>map&lt;string, <span class=type>int</span>&gt; myMap;</span><br><span class=line>myMap[<span class=string>&quot;apple&quot;</span>] = <span class=number>10</span>;</span><br><span class=line>cout &lt;&lt; myMap[<span class=string>&quot;apple&quot;</span>]; <span class=comment>// 输出 10</span></span><br></pre></td></tr></table></figure><h5 id=集合（Set）><a href=#集合（Set） class=headerlink title=集合（Set）></a><strong>集合（Set）</strong></h5><p><code>set</code> 是一种用于存储唯一元素的有序集合，底层同样使用红黑树实现。它保证元素不重复且有序。</p><ul><li>保证元素的唯一性。</li><li>元素自动按升序排列。</li><li>时间复杂度为 O(log n)。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>set&lt;<span class=type>int</span>&gt; s;</span><br><span class=line>s.<span class=built_in>insert</span>(<span class=number>1</span>);</span><br><span class=line>s.<span class=built_in>insert</span>(<span class=number>2</span>);</span><br><span class=line>cout &lt;&lt; *s.<span class=built_in>begin</span>(); <span class=comment>// 输出 1</span></span><br></pre></td></tr></table></figure><h2 id=7、线程和进程><a href=#7、线程和进程 class=headerlink title=7、线程和进程></a>7、线程和进程</h2><h3 id=7-1、进程><a href=#7-1、进程 class=headerlink title=7.1、进程></a>7.1、进程</h3><ul><li>进程是操作系统中的一个独立执行单元。每个进程都有独立的内存空间、程序代码、数据和系统资源。</li><li>进程间通信相对复杂，通常需要通过进程间通信机制（IPC，Inter-Process Communication）来实现，如消息队列、信号量、管道等。</li><li>进程切换的代价相对较高，因为切换时需要保存和恢复完整的上下文信息，包括内存、寄存器等。</li></ul><h3 id=7-2、线程><a href=#7-2、线程 class=headerlink title=7.2、线程></a>7.2、线程</h3><ul><li>线程是程序执行中的单一顺序控制流，多个线程可以在同一个进程中独立运行。</li><li>线程除了线程栈外其他数据都是共享的，如果同时读写数据可能造成数据不一致甚至程序崩溃的后果，因此<strong>线程之间重点关注同步</strong>。</li><li>最常解决竞争条件的方式是<strong>原子操作</strong>，其次便是<strong>线程同步</strong>。</li></ul><h4 id=7-2-1、原子操作><a href=#7-2-1、原子操作 class=headerlink title=7.2.1、原子操作></a>7.2.1、原子操作</h4><p>原子操作，一般都是指“不可分割的操作”；是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。</p><p>正常情况下，我们想到就是使用<code>mutex</code>来解决上述对临界资源访问的问题，使用<code>mutex</code>程序执行不会导致混乱，但是每一次循环都要加锁解锁是的程序开销很大。 而原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能。</p><p>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。</p><h5 id=atomic><a href=#atomic class=headerlink title=atomic></a>atomic</h5><p>为了提高性能，C++11提供了原子类型<code>atomic&lt;T&gt;</code>，它提供了多线程间的原子操作，可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p><p>它定义在<code>&lt;atomic&gt;</code>头文件中，原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。这个类型必须有拷贝赋值运算符。这就意味着这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的拷贝赋值操作。不仅仅是这些，自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。</p><p><code>atomic</code>模板允许用户使用自定义类型创建一个原子变量</p><ul><li><code>load()</code>: 安全地读取原子变量的值。</li><li><code>store(value)</code>: 安全地将值写入原子变量。</li><li><code>exchange(value)</code>: 将原子变量的值替换为<code>value</code>，并返回原子变量的旧值。</li><li><code>compare_exchange_weak(expected, desired)</code>: 如果原子变量的当前值等于<code>expected</code>，则将其设置为<code>desired</code>，并返回<code>true</code>。否则，将<code>expected</code>设置为原子变量的当前值，并返回<code>false</code>。</li><li><code>compare_exchange_strong(expected, desired)</code>: 与<code>compare_exchange_weak</code>类似，但循环直到成功。</li></ul><h4 id=7-2-2、线程同步><a href=#7-2-2、线程同步 class=headerlink title=7.2.2、线程同步></a>7.2.2、线程同步</h4><h5 id=互斥锁><a href=#互斥锁 class=headerlink title=互斥锁></a>互斥锁</h5><p><code>mutex</code>是睡眠等待（sleep waiting）类型的锁，<strong>当线程抢互斥锁失败的时候，线程会陷入休眠</strong>。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。它有 <strong><em>lock</em></strong> 和 <strong><em>unlock</em></strong> 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取</p><h6 id=lock-guard><a href=#lock-guard class=headerlink title=lock_guard></a>lock_guard</h6><p>自动加锁：当一个 <code>lock_guard</code> 对象被创建时，它会自动为传入的 <code>mutex</code> 锁加锁。</p><p>自动释放锁：当 <code>lock_guard</code> 对象超出作用域时，它会自动释放锁。</p><h5 id=条件变量><a href=#条件变量 class=headerlink title=条件变量></a>条件变量</h5><p>并发有互斥和等待两大需求，前者是因为线程间存在共享数据依赖而后者是线程间存在依赖，条件变量正是为了解决等待需求。</p><p>条件变量本质上也是一个多线程间共享的全局变量，它的功能是阻塞线程，被阻塞的线程直到接收到“条件成立”的信号后才能继续执行。</p><ul><li>条件变量并不是锁（但它几乎总是和互斥量一起使用的），而是线程间的一种通讯机制</li><li>条件变量本身也不包含条件，它被称为条件变量是因为它经常和条件语句（if/while）一起使用</li></ul><p>条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。</p><p>具体流程：</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>手动上锁——&gt;判断条件不满足——&gt;[条件变量自动解锁、阻塞线程、等待信号—— ——&gt;自动上锁]——&gt;判断条件满足——&gt;执行代码——&gt;手动解锁</span><br><span class=line>					       [其他线程准备好条件后发送信号唤醒——^] <span class=comment>// 中括号中为系统封装，中括号外需要程序员实现</span></span><br></pre></td></tr></table></figure><p>背景：轮询模式与事件模式。以生产者和消费者模型为例。。。</p><h5 id=读写锁><a href=#读写锁 class=headerlink title=读写锁></a>读写锁</h5><p>读写锁也称之为 <strong>共享-独占锁</strong>，一般用在<strong>读操作次数多于写操作次数</strong>的场合。</p><p>相较于互斥锁而言<strong>读写锁有一定的性能提升</strong>，应对的是单写多读模型：</p><ul><li>写独占：写锁占用时，其他线程加读锁或者写锁时都会阻塞（并非失败）</li><li>读共享：读锁占用时，其他线程加写锁时会阻塞，加读锁会成功</li></ul><p>读写锁有两种策略：</p><ul><li>强读同步：读锁优先，只要写锁没有占用那么就可以加读锁</li><li>强写同步：写锁优先，只能等到所有正在等待或者执行的写锁执行完成后才能加读锁</li></ul><p>大部分读写锁的实现都采用的是“强写同步”策略，对尝试加锁的操作进行排队，如果前面已经有尝试加写被锁阻塞住的话，后续加读锁也都会被阻塞住（尽管当前时刻是读锁占用的状态）。这样做的目的主要是为了避免“写饥饿”，在“多读少写”的情况下防止数据修改延迟过高。</p><h5 id=信号量><a href=#信号量 class=headerlink title=信号量></a>信号量</h5><p>信号量分为有名信号量和无名信号量，无名信号量用于线程同步，有名信号量一般用于进程之间管理。</p><p>信号量本质上是一个非负的整数计数器，用于控制公共资源的访问，也被称为PV原子操作：</p><ul><li>P操作：“等待”操作，信号量<code>sem</code>先减一，若<code>sem</code>小于等于0则<code>P操作</code>被阻塞，直到有其他线程通过 <code>V操作</code> 将信号量的值增加至大于 0，从而唤醒等待的线程。</li><li>V操作：“释放”操作，信号量<code>sem</code>加一，若 <code>sem</code> 小于等于 0，表示有线程在等待信号量，<code>V操作</code> 会唤醒其中一个等待的线程。</li></ul><p>信号量允许<strong>多个线程</strong>同时进入临界区，而互斥量只允许<strong>一个线程</strong>进入临界区。</p><p>可以这样理解，互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步</p><h2 id=8、C-标准库><a href=#8、C-标准库 class=headerlink title="8、C++ 标准库"></a>8、C++ 标准库</h2><h3 id=8-1、容器><a href=#8-1、容器 class=headerlink title=8.1、容器></a>8.1、容器</h3><h4 id=8-1-1、顺序容器><a href=#8-1-1、顺序容器 class=headerlink title=8.1.1、顺序容器></a>8.1.1、顺序容器</h4><h5 id=string><a href=#string class=headerlink title=string></a>string</h5><p>使用 <code>+</code> 连接字符串</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>std::string str1 = <span class=string>&quot;Hello, &quot;</span>;</span><br><span class=line>std::string str2 = <span class=string>&quot;World!&quot;</span>;</span><br><span class=line>std::string result = str1 + str2;</span><br></pre></td></tr></table></figure><ul><li><p><code>getline(cin, str)</code>：可以获取空格，以enter结尾</p></li><li><p><code>size()</code>：返回字符串的长度。</p></li><li><p><code>empty()</code>：检查字符串是否为空。</p></li><li><p><code>substr()</code>：返回从指定位置开始的子字符串。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function>string <span class=title>substr</span><span class=params>(<span class=type>size_t</span> __pos = <span class=number>0</span>, <span class=type>size_t</span> __n = npos)</span></span>;<span class=comment>// 返回从pos开始的n个字符</span></span><br></pre></td></tr></table></figure></li><li><p><code>find()</code>：查找子字符串在主字符串中的位置。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=type>size_t</span> <span class=title>find</span><span class=params>(basic_string&amp; __str, <span class=type>size_t</span> __pos)</span></span>;<span class=comment>// 从pos开始查找str的位置</span></span><br><span class=line><span class=function><span class=type>size_t</span> <span class=title>find</span><span class=params>(<span class=type>char</span> *__s, <span class=type>size_t</span> __pos, <span class=type>size_t</span> __n)</span></span>;<span class=comment>// 从pos开始查找以s开头长度为n的字符串的位置</span></span><br></pre></td></tr></table></figure></li><li><p><code>replace()</code>：替换字符串中的某些字符。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function>string &amp;<span class=title>replace</span><span class=params>(<span class=type>size_t</span> __pos, <span class=type>size_t</span> __n1, basic_string&amp; __str)</span></span>;<span class=comment>// 替换从pos开始的n个字符为str</span></span><br></pre></td></tr></table></figure></li><li><p><code>insert()</code>：在指定位置插入内容。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=function>string &amp;<span class=title>insert</span><span class=params>(<span class=type>size_t</span> __pos, basic_string&amp; __str)</span></span>;<span class=comment>// 在pos处插入str</span></span><br><span class=line><span class=function>string &amp;<span class=title>insert</span><span class=params>(<span class=type>size_t</span> __pos, <span class=type>size_t</span> __n, <span class=type>char</span> *__c)</span></span>;<span class=comment>// 在pos处插入n个char c</span></span><br></pre></td></tr></table></figure></li><li><p><code>append()</code>：在字符串末尾添加内容。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function>string &amp;<span class=title>append</span><span class=params>(basic_string&amp; __str)</span></span>;<span class=comment>// 末尾添加</span></span><br></pre></td></tr></table></figure></li><li><p><code>erase()</code>：删除指定位置的字符或子字符串。</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=function>string&amp; <span class=title>erase</span><span class=params>(<span class=type>size_t</span> pos = <span class=number>0</span>, <span class=type>size_t</span> n = npos)</span></span>;<span class=comment>// 删除从pos开始的n个字符</span></span><br><span class=line><span class=function>iterator <span class=title>erase</span><span class=params>(iterator position)</span></span>;             <span class=comment>// 删除position处的一个字符(position是个string类型的迭代器)</span></span><br><span class=line><span class=function>iterator <span class=title>erase</span><span class=params>(iterator first, iterator last)</span></span>; <span class=comment>// 删除从first到last之间的字符(first和last都是迭代器)</span></span><br></pre></td></tr></table></figure></li></ul><h5 id=vector><a href=#vector class=headerlink title=vector></a>vector</h5><ul><li><p><code>erase()</code> ：从指定容器删除指定位置的元素或某段范围内的元素</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=function>iterator <span class=title>erase</span><span class=params>( iterator _Where)</span></span>;<span class=comment>// 删除指定位置的元素，返回值是一个迭代器，指向删除元素的下一个元素；</span></span><br><span class=line><span class=function>iterator <span class=title>erase</span><span class=params>( iterator _First,   iterator _Last)</span></span>;<span class=comment>// 删除从_First开始到_Last位置的元素</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>for</span>(vector&lt;<span class=type>int</span>&gt;::iterator it=arr.<span class=built_in>begin</span>(); it!=arr.<span class=built_in>end</span>(); )</span><br><span class=line>&#123;</span><br><span class=line>    <span class=keyword>if</span>(* it == <span class=number>0</span>) </span><br><span class=line>    &#123;</span><br><span class=line>        it = arr.<span class=built_in>erase</span>(it);<span class=comment>//vector后面的元素会向前移位，形成新的容器，这样原来指向删除元素的迭代器（_Where）就失效了。</span></span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>else</span> </span><br><span class=line>    &#123;</span><br><span class=line>        ++it;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;<span class=comment>// 注意：调用erase(it)后，语义上来说it失效了，实际上指向的元素变成了下一个元素，再执行it++导致跳过该元素</span></span><br></pre></td></tr></table></figure><h5 id=list><a href=#list class=headerlink title=list></a>list</h5><h5 id=deque><a href=#deque class=headerlink title=deque></a>deque</h5><p>双端队列，<code>deque</code> 是在队列的两端都可以进行插入和删除的队列，且增删的效率均为O(1)。<code>deque</code> 支持随机访问，在表面上看起来是连续存储的，但在底层实现中却不是完全连续，而是分段连续的。</p><p><code>deque</code> 有一个中控器，中控器中包含了每一段连续地址的大小、开始地址（迭代器）、结束地址（迭代器），并包含一个指向开始地址的指针。实际访问到一个地址的元素，需要先访问中控器，找到相应的缓冲区，再在缓冲区中找到目标元素。因此 <code>deque</code> 的<strong>随机访问</strong>是比 <code>vector</code> 低效的。</p><p>与 <code>vector</code> 比较， 其头部插入和删除以及扩容时，不需要搬移元素，因此其效率是必vector高的。<br>与 <code>list</code> 比较， 其底层是连续空间，空间利用率比较高，不需要存储额外字段。</p><p>但是，<code>deque</code> 有一个致命缺陷：不适合遍历。因为在遍历时，<code>deque</code> 的迭代器要频繁的去检测是否移动到某段小空间的边界，导致效率低下，而序列式场景中，可能需要经常遍历，因此在实际中，需要线性结构时，大多数情况下优先考虑 <code>vector</code> 和 <code>list</code></p><p><code>deque</code> 的应用并不多，而目前能看到的一个应用就是，STL用其作为 <code>stack</code> 和 <code>queue</code> 的底层数据结构。</p><h4 id=8-1-2、关联容器><a href=#8-1-2、关联容器 class=headerlink title=8.1.2、关联容器></a>8.1.2、关联容器</h4><h5 id=set><a href=#set class=headerlink title=set></a>set</h5><h5 id=map><a href=#map class=headerlink title=map></a>map</h5><h3 id=8-2、容器适配器><a href=#8-2、容器适配器 class=headerlink title=8.2、容器适配器></a>8.2、容器适配器</h3><p><strong>适配器是指将一个类型的接口转化为另外一个接口</strong>。C++中的容器适配器的意思便是：在C++提供的<strong>底层容器的基础</strong>上实现我们所希望的功能，而向外表现出和容器一样的特点。</p><h5 id=stack><a href=#stack class=headerlink title=stack></a>stack</h5><h5 id=queue><a href=#queue class=headerlink title=queue></a>queue</h5><p>只要支持以下几种操作的容器均可作为<code>stack</code>和<code>queue</code>的底层容器：</p><ul><li>empty()：检测容器是否为空</li><li>size()：返回容器中有效元素个数</li><li>front()：返回容器中第一个元素的引用</li><li>push_back()：在容器尾部插入元素</li><li>pop_back()：删除容器尾部元素</li></ul><h5 id=priority-queue><a href=#priority-queue class=headerlink title=priority_queue></a>priority_queue</h5><p><strong>优先队列</strong>，是基于堆这种数据结构实现的，允许我们快速访问队列中具有最高（或最低）优先级的元素，但不支持随机访问也不提供迭代器。所以<code>priority_queue</code> 实际上是一个容器适配器，它提供了<strong>对底层容器的堆操作</strong>，其可选的底层容器包括vector、deque等，但注意<strong>不能使用list</strong>（list不支持随机访问迭代器。<code>priority_queue</code> 需要能够通过索引或迭代器直接访问任意元素），STL<strong>默认使用vector</strong>。</p><p>在 C++ 中，<code>priority_queue</code> 默认是一个最大堆，队列的顶部元素总是具有最大的值。</p><p>堆是一个特别完全二叉树的结构，即满足 父结点的键值总是大于（或者小于）它的子节点 的完全二叉树。</p><p>父节点的值恒小于等于子节点的值，称为最小堆（min heap）；父节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）</p><ul><li><p><code>empty()</code>: 检查队列是否为空。</p></li><li><p><code>size()</code>: 返回队列中的元素数量。</p></li><li><p><code>top()</code>: 返回队列顶部的元素（不删除它）。</p></li><li><p><code>push()</code>: 向队列添加一个元素。</p></li><li><p><code>pop()</code>: 移除队列顶部的元素。</p><p>优先级判断重载：</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">student</span> <span class=comment>// 法一：运算符重载&lt;</span></span><br><span class=line>&#123;</span><br><span class=line>  string name;</span><br><span class=line>  <span class=type>int</span> age;</span><br><span class=line>  <span class=built_in>student</span>(<span class=type>int</span> a) &#123;age = a;&#125;</span><br><span class=line>  <span class=type>bool</span> <span class=keyword>operator</span>&lt;(<span class=type>const</span> student&amp; a) <span class=type>const</span></span><br><span class=line>  &#123;</span><br><span class=line>	<span class=keyword>return</span> age &lt; a.age;<span class=comment>// 不改变&lt;语义，按默认大的在堆顶</span></span><br><span class=line>  &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">ageCompare</span> <span class=comment>// 法二：重写仿函数</span></span><br><span class=line>&#123;</span><br><span class=line>  <span class=function><span class=type>bool</span> <span class=title>operator</span><span class=params>()</span> <span class=params>(student a, student b)</span> </span></span><br><span class=line><span class=function>  </span>&#123;</span><br><span class=line>	<span class=keyword>return</span> a.age &gt; b.age; <span class=comment>// 返回true代表后者优先级高放在堆顶，此处为年龄小的优先级高</span></span><br><span class=line>  &#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=function><span class=type>int</span> <span class=title>main</span><span class=params>()</span> </span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>  priority_queue&lt;student&gt; students;</span><br><span class=line>  <span class=comment>// priority_queue&lt;student, vector&lt;student&gt;, ageCompare&gt; students;</span></span><br><span class=line></span><br><span class=line>  students.<span class=built_in>push</span>(<span class=built_in>student</span>(<span class=number>10</span>));</span><br><span class=line>  students.<span class=built_in>push</span>(<span class=built_in>student</span>(<span class=number>20</span>));</span><br><span class=line>  students.<span class=built_in>push</span>(<span class=built_in>student</span>(<span class=number>15</span>));</span><br><span class=line>  cout &lt;&lt; students.<span class=built_in>top</span>().age &lt;&lt; endl;</span><br><span class=line>    </span><br><span class=line>  <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id=8-3、其他><a href=#8-3、其他 class=headerlink title=8.3、其他></a>8.3、其他</h3><h4 id=sstream><a href=#sstream class=headerlink title=sstream></a>sstream</h4></article><div class=post-copyright><div class=copyright-cc-box><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class=post-copyright__author_box><a class=post-copyright__author_img href=/myself/ title=头像><img class=post-copyright__author_img_back src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/keqing.webp title=头像 alt=头像><img class=post-copyright__author_img_front src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/keqing.webp title=头像 alt=头像></a><div class=post-copyright__author_name>x1ang</div><div class=post-copyright__author_desc>东隅已逝 桑榆非晚</div></div><div class=post-copyright__post__info><a class=post-copyright__original title=该文章为原创文章，注意版权协议 href=https://x1ang.com/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ >原创</a><a class=post-copyright-title><span onclick='rm.copyPageUrl("https://x1ang.com/2025/03/15/C-查漏补缺/")'>C++查漏补缺</span></a></div><div class=post-tools id=post-tools><div class=post-tools-left><div class=rewardLeftButton><div class=post-reward onclick=anzhiyu.addRewardMask()><div class="reward-button button--animated" title=赞赏作者><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class=reward-main><div class=reward-all><span class=reward-title>感谢你赐予我前进的力量</span><ul class=reward-group><li class=reward-item><a href=https://assets.blog.x1ang.com/config/wechat.webp target=_blank><img class=post-qr-code-img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/wechat.webp alt=微信></a><div class=post-qr-code-desc>微信</div></li><li class=reward-item><a href=https://assets.blog.x1ang.com/config/alipay.webp target=_blank><img class=post-qr-code-img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/alipay.webp alt=支付宝></a><div class=post-qr-code-desc>支付宝</div></li></ul><a class=reward-main-btn href=/about/#about-reward target=_blank><div class=reward-text>赞赏者名单</div><div class=reward-dec>因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id=quit-box onclick=anzhiyu.removeRewardMask() style=display:none></div></div><div class=shareRight><div class="share-link mobile"><div class=share-qrcode><div class=share-button title=使用手机访问这篇文章><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class=share-main><div class=share-main-all><div id=qrcode title=https://x1ang.com/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ ></div><div class=reward-dec>使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class=share-button target=_blank href="https://service.weibo.com/share/share.php?title=C++查漏补缺&amp;url=https://x1ang.com/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/&amp;pic=https://assets.blog.x1ang.com/default_cover_3.webp?_r_=cac6baa4-5d41-2724-b865-44d3c48e3c49" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class=share-button id=post-share-url title=复制链接 onclick=copyCurrentPageUrl()><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class=post-copyright__notice><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href=https://x1ang.com target=_blank>x1ang</a>！</span></div></div><div class=post-tools-right><div class=tag_share><div class=post-meta__box><div class=post-meta__box__tag-list><a class=post-meta__box__tags href=/tags/C/ ><span class=tags-punctuation><i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class=tagsPageCount>1</span></a></div></div></div><div class=post_share><div class=social-share data-image="https://assets.blog.x1ang.com/default_cover_2.webp?_r_=5d7e37b1-2070-cc65-61c9-d817887dbac0" data-sites=facebook,twitter,wechat,qq,qzone></div><link rel=stylesheet href=https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css media=print onload='this.media="all"'><script src=https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js defer=defer></script></div></div><nav class=pagination-post id=pagination><div class="prev-post pull-left"><a href=/2024/10/28/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B0%AE%E5%8C%96%E9%95%93%E7%94%B5%E6%BA%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/ ><img class=prev-cover src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://photo.x1ang.com/241019-c170电源/c170.webp onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class=pagination-info><div class=label>上一篇</div><div class=prev_info>笔记本氮化镓电源使用指北</div></div></a></div><div class="next-post pull-right"><a href=/2025/09/19/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/ ><img class=next-cover src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://assets.blog.x1ang.com/default_cover_2.webp?_r_=5d7e37b1-2070-cc65-61c9-d817887dbac0" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class=pagination-info><div class=label>下一篇</div><div class=next_info>butterfly主题魔改</div></div></a></div></nav><hr><div id=post-comment><div class=comment-head><div class=comment-headline><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class=comment-randomInfo><a onclick=anzhiyu.addRandomCommentInfo() href=javascript:void(0)>匿名评论</a><a href=/privacy style=margin-left:4px>隐私政策</a></div><div class=comment-tips id=comment-tips><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class=comment-wrap><div><div id=twikoo-wrap></div></div></div></div><div class=comment-barrage></div></div><div class=aside-content id=aside-content><div class="card-widget card-info"><div class=card-content><div class=author-info__sayhi id=author-info__sayhi onclick=anzhiyu.changeSayHelloText()></div><div class=author-info-avatar><img class=avatar-img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/keqing.webp onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt=avatar><div class=author-status><img class=g-status src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/doge.png alt=status></div></div><div class=author-info__description><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">相信你可以在这里找到对你有用的<b style=color:#fff>知识</b>和<b style=color:#fff>教程</b>。</div></div><div class=author-info__bottom-group><a class=author-info__bottom-group-left href=/myself><h1 class=author-info__name>x1ang</h1><div class=author-info__desc>东隅已逝 桑榆非晚</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href=https://github.com/x1angji target=_blank title=Github><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href=https://steamcommunity.com/id/x1angji/ target=_blank title=Steam><i class="fab fa-steam faa-tada"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class=item-headline><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class=announcement_content>笔记正在陆续整理上传~</div></div><div class=sticky_layout><div class=card-widget id=card-toc><div class=item-headline><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class=toc-percentage></span></div><div class=toc-content><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#%E4%B8%80%E3%80%81%E5%90%B8%E4%BD%B3%E4%BD%B3%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA><span class=toc-number>1.</span> <span class=toc-text>一、吸佳佳查漏补缺</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%BC%96%E8%AF%91%E5%99%A8><span class=toc-number>1.1.</span> <span class=toc-text>编译器</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#c-11><span class=toc-number>1.2.</span> <span class=toc-text>c++11</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89><span class=toc-number>1.2.1.</span> <span class=toc-text>移动语义</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC><span class=toc-number>1.2.1.0.1.</span> <span class=toc-text>左值和右值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86><span class=toc-number>1.3.</span> <span class=toc-text>内存管理</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA><span class=toc-number>1.3.0.1.</span> <span class=toc-text>内存分区</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88><span class=toc-number>1.3.0.2.</span> <span class=toc-text>智能指针</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#auto-ptr%EF%BC%88%E5%B7%B2%E5%BC%83%E7%94%A8%EF%BC%89><span class=toc-number>1.3.0.2.1.</span> <span class=toc-text>auto_ptr（已弃用）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#unique-ptr><span class=toc-number>1.3.0.2.2.</span> <span class=toc-text>unique_ptr</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class=toc-link href=#1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97><span class=toc-number>1.4.</span> <span class=toc-text>1、关键字</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#inline><span class=toc-number>1.4.0.0.1.</span> <span class=toc-text>inline</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#new%E4%B8%8Emalloc><span class=toc-number>1.4.0.0.2.</span> <span class=toc-text>new与malloc</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#const-%E4%B8%8E-constexpr><span class=toc-number>1.4.0.0.3.</span> <span class=toc-text>const 与 constexpr</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#volatile><span class=toc-number>1.4.0.0.4.</span> <span class=toc-text>volatile</span></a></li></ol></li><li class="toc-item toc-level-4"><a class=toc-link href=#1-1%E3%80%81%E5%82%A8%E5%AD%98%E7%B1%BB><span class=toc-number>1.4.0.1.</span> <span class=toc-text>1.1、储存类</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#mutable><span class=toc-number>1.4.0.1.1.</span> <span class=toc-text>mutable</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#extern><span class=toc-number>1.4.0.1.2.</span> <span class=toc-text>extern</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#thread-local><span class=toc-number>1.4.0.1.3.</span> <span class=toc-text>thread_local</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#static><span class=toc-number>1.4.0.1.4.</span> <span class=toc-text>static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#2%E3%80%81Lambda%E5%87%BD%E6%95%B0%E4%B8%8E%E8%A1%A8%E8%BE%BE><span class=toc-number>1.5.</span> <span class=toc-text>2、Lambda函数与表达</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#3%E3%80%81%E9%9A%8F%E6%9C%BA%E6%95%B0><span class=toc-number>1.6.</span> <span class=toc-text>3、随机数</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#rand><span class=toc-number>1.6.0.0.1.</span> <span class=toc-text>rand</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#random-device><span class=toc-number>1.6.0.0.2.</span> <span class=toc-text>random_device</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#mt19937><span class=toc-number>1.6.0.0.3.</span> <span class=toc-text>mt19937</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#shuffle><span class=toc-number>1.6.0.0.4.</span> <span class=toc-text>shuffle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#4%E3%80%81%E6%A8%A1%E6%9D%BF><span class=toc-number>1.7.</span> <span class=toc-text>4、模板</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF><span class=toc-number>1.7.0.0.1.</span> <span class=toc-text>函数模板</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E7%B1%BB%E6%A8%A1%E6%9D%BF><span class=toc-number>1.7.0.0.2.</span> <span class=toc-text>类模板</span></a><ol class=toc-child><li class="toc-item toc-level-6"><a class=toc-link href=#%E5%AE%9E%E4%BE%8B><span class=toc-number>1.7.0.0.2.1.</span> <span class=toc-text>实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#6%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=toc-number>1.8.</span> <span class=toc-text>6、数据结构</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89><span class=toc-number>1.8.0.0.1.</span> <span class=toc-text>链表（Linked List）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%A0%88%EF%BC%88Stack%EF%BC%89><span class=toc-number>1.8.0.0.2.</span> <span class=toc-text>栈（Stack）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89><span class=toc-number>1.8.0.0.3.</span> <span class=toc-text>队列（Queue）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%88Deque%EF%BC%89><span class=toc-number>1.8.0.0.4.</span> <span class=toc-text>双端队列（Deque）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89><span class=toc-number>1.8.0.0.5.</span> <span class=toc-text>哈希表（Hash Table）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8><span class=toc-number>1.8.0.0.6.</span> <span class=toc-text>哈希表的应用</span></a><ol class=toc-child><li class="toc-item toc-level-6"><a class=toc-link href=#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8><span class=toc-number>1.8.0.0.6.1.</span> <span class=toc-text>布隆过滤器</span></a></li><li class="toc-item toc-level-6"><a class=toc-link href=#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C><span class=toc-number>1.8.0.0.6.2.</span> <span class=toc-text>一致性哈希</span></a></li></ol></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%98%A0%E5%B0%84%EF%BC%88Map%EF%BC%89><span class=toc-number>1.8.0.0.7.</span> <span class=toc-text>映射（Map）</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89><span class=toc-number>1.8.0.0.8.</span> <span class=toc-text>集合（Set）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#7%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B><span class=toc-number>1.9.</span> <span class=toc-text>7、线程和进程</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#7-1%E3%80%81%E8%BF%9B%E7%A8%8B><span class=toc-number>1.9.1.</span> <span class=toc-text>7.1、进程</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#7-2%E3%80%81%E7%BA%BF%E7%A8%8B><span class=toc-number>1.9.2.</span> <span class=toc-text>7.2、线程</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#7-2-1%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C><span class=toc-number>1.9.2.1.</span> <span class=toc-text>7.2.1、原子操作</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#atomic><span class=toc-number>1.9.2.1.1.</span> <span class=toc-text>atomic</span></a></li></ol></li><li class="toc-item toc-level-4"><a class=toc-link href=#7-2-2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5><span class=toc-number>1.9.2.2.</span> <span class=toc-text>7.2.2、线程同步</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E4%BA%92%E6%96%A5%E9%94%81><span class=toc-number>1.9.2.2.1.</span> <span class=toc-text>互斥锁</span></a><ol class=toc-child><li class="toc-item toc-level-6"><a class=toc-link href=#lock-guard><span class=toc-number>1.9.2.2.1.1.</span> <span class=toc-text>lock_guard</span></a></li></ol></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F><span class=toc-number>1.9.2.2.2.</span> <span class=toc-text>条件变量</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E8%AF%BB%E5%86%99%E9%94%81><span class=toc-number>1.9.2.2.3.</span> <span class=toc-text>读写锁</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E4%BF%A1%E5%8F%B7%E9%87%8F><span class=toc-number>1.9.2.2.4.</span> <span class=toc-text>信号量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#8%E3%80%81C-%E6%A0%87%E5%87%86%E5%BA%93><span class=toc-number>1.10.</span> <span class=toc-text>8、C++ 标准库</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#8-1%E3%80%81%E5%AE%B9%E5%99%A8><span class=toc-number>1.10.1.</span> <span class=toc-text>8.1、容器</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#8-1-1%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8><span class=toc-number>1.10.1.1.</span> <span class=toc-text>8.1.1、顺序容器</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#string><span class=toc-number>1.10.1.1.1.</span> <span class=toc-text>string</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#vector><span class=toc-number>1.10.1.1.2.</span> <span class=toc-text>vector</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#list><span class=toc-number>1.10.1.1.3.</span> <span class=toc-text>list</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#deque><span class=toc-number>1.10.1.1.4.</span> <span class=toc-text>deque</span></a></li></ol></li><li class="toc-item toc-level-4"><a class=toc-link href=#8-1-2%E3%80%81%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8><span class=toc-number>1.10.1.2.</span> <span class=toc-text>8.1.2、关联容器</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#set><span class=toc-number>1.10.1.2.1.</span> <span class=toc-text>set</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#map><span class=toc-number>1.10.1.2.2.</span> <span class=toc-text>map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#8-2%E3%80%81%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8><span class=toc-number>1.10.2.</span> <span class=toc-text>8.2、容器适配器</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#stack><span class=toc-number>1.10.2.0.1.</span> <span class=toc-text>stack</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#queue><span class=toc-number>1.10.2.0.2.</span> <span class=toc-text>queue</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#priority-queue><span class=toc-number>1.10.2.0.3.</span> <span class=toc-text>priority_queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#8-3%E3%80%81%E5%85%B6%E4%BB%96><span class=toc-number>1.10.3.</span> <span class=toc-text>8.3、其他</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#sstream><span class=toc-number>1.10.3.1.</span> <span class=toc-text>sstream</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class=item-headline><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class=aside-list><div class=aside-list-item><a class=thumbnail href=/2025/09/19/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/ title=butterfly主题魔改><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://assets.blog.x1ang.com/default_cover_2.webp?_r_=5d7e37b1-2070-cc65-61c9-d817887dbac0" onerror='this.onerror=null,this.src="/img/404.jpg"' alt=butterfly主题魔改></a><div class=content><a class=title href=/2025/09/19/butterfly%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/ title=butterfly主题魔改>butterfly主题魔改</a><time datetime=2025-09-19T14:41:42.000Z title="发表于 2025-09-19 22:41:42">2025-09-19</time></div></div><div class=aside-list-item><a class=thumbnail href=/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ title=C++查漏补缺><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://assets.blog.x1ang.com/default_cover_3.webp?_r_=cac6baa4-5d41-2724-b865-44d3c48e3c49" onerror='this.onerror=null,this.src="/img/404.jpg"' alt=C++查漏补缺></a><div class=content><a class=title href=/2025/03/15/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/ title=C++查漏补缺>C++查漏补缺</a><time datetime=2025-03-15T04:00:00.000Z title="发表于 2025-03-15 12:00:00">2025-03-15</time></div></div><div class=aside-list-item><a class=thumbnail href=/2024/10/28/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B0%AE%E5%8C%96%E9%95%93%E7%94%B5%E6%BA%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/ title=笔记本氮化镓电源使用指北><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://photo.x1ang.com/241019-c170电源/c170.webp onerror='this.onerror=null,this.src="/img/404.jpg"' alt=笔记本氮化镓电源使用指北></a><div class=content><a class=title href=/2024/10/28/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B0%AE%E5%8C%96%E9%95%93%E7%94%B5%E6%BA%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/ title=笔记本氮化镓电源使用指北>笔记本氮化镓电源使用指北</a><time datetime=2024-10-28T04:00:00.000Z title="发表于 2024-10-28 12:00:00">2024-10-28</time></div></div><div class=aside-list-item><a class=thumbnail href=/2024/10/18/%E7%B4%AB%E9%87%91%E5%B1%B1-%E9%98%BF%E7%89%B9%E6%8B%89%E6%96%AF%E5%BD%97%E6%98%9F/ title=紫金山-阿特拉斯彗星><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://photo.x1ang.com/241012-紫金山-阿特拉斯彗星/紫金山-阿特拉斯彗星.webp onerror='this.onerror=null,this.src="/img/404.jpg"' alt=紫金山-阿特拉斯彗星></a><div class=content><a class=title href=/2024/10/18/%E7%B4%AB%E9%87%91%E5%B1%B1-%E9%98%BF%E7%89%B9%E6%8B%89%E6%96%AF%E5%BD%97%E6%98%9F/ title=紫金山-阿特拉斯彗星>紫金山-阿特拉斯彗星</a><time datetime=2024-10-18T04:00:00.000Z title="发表于 2024-10-18 12:00:00">2024-10-18</time></div></div></div></div></div></div></div></main><footer id=footer><div id=footer-wrap><div id=workboard><div id=runtimeTextTip></div></div><p id=ghbdages><a class=github-badge target=_blank href=https://hexo.io/ style=margin-inline:5px data-title=博客框架为Hexo_v7.0.0 title=博客框架为Hexo_v7.0.0><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Frame-Hexo.svg alt=博客框架为Hexo_v7.0.0></a><a class=github-badge target=_blank href=https://blog.anheyu.com/ style=margin-inline:5px data-title=本站使用AnZhiYu主题 title=本站使用AnZhiYu主题><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Theme-AnZhiYu-2E67D3.svg alt=本站使用AnZhiYu主题></a><a class=github-badge target=_blank href=https://hyperos.mi.com/font/zh/ style=margin-inline:5px data-title="本站使用 MiSans 字体" title="本站使用 MiSans 字体"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Font-Misans-EC6617.svg alt="本站使用 MiSans 字体"></a><a class=github-badge target=_blank href=https://github.com/ style=margin-inline:5px data-title=本站项目由Github托管 title=本站项目由Github托管><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Source-Github.svg alt=本站项目由Github托管></a><a class=github-badge target=_blank href=https://vercel.com/ style=margin-inline:5px data-title=本站线路托管于Vercel title=本站线路托管于Vercel><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Hosted-Vercel-brightgreen.svg alt=本站线路托管于Vercel></a><a class=github-badge target=_blank href=http://creativecommons.org/licenses/by-nc-sa/4.0/ style=margin-inline:5px data-title=本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可 title=本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://assets.blog.x1ang.com/config/Copyright-BY-NC-SA.svg alt=本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可></a></p></div><div id=footer-bar><div class=footer-bar-links><div class=footer-bar-left><div id=footer-bar-tips><div class=copyright>&copy;2025 By <a class=footer-bar-link href=/ title=x1ang target=_blank>x1ang</a></div></div><div id=footer-type-tips></div></div><div class=footer-bar-right><a class=footer-bar-link target=_blank rel=noopener href=https://github.com/anzhiyu-c/hexo-theme-anzhiyu title=主题>主题</a></div></div></div></footer></div><div id=sidebar><div id=menu-mask></div><div id=sidebar-menus><div class="sidebar-site-data site-data is-center"><a href=/archives/ title=archive><div class=headline>文章</div><div class=length-num>4</div></a><a href=/tags/ title=tag><div class=headline>标签</div><div class=length-num>7</div></a><a href=/categories/ title=category><div class=headline>分类</div><div class=length-num>3</div></a></div><span class=sidebar-menu-item-title>功能</span><div class=sidebar-menu-item><a class="darkmode_switchbutton menu-child" href=javascript:void(0); title=显示模式><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class=back-menu-list-groups><div class=back-menu-list-group><div class=back-menu-list-title>网页</div><div class=back-menu-list><a class=back-menu-item href=https://x1ang.com/ title=博客><img class=back-menu-item-icon src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=/img/favicon.ico alt=博客><span class=back-menu-item-text>博客</span></a></div></div><div class=back-menu-list-group><div class=back-menu-list-title>项目</div><div class=back-menu-list><a class=back-menu-item target=_blank rel=noopener href=https://image.anheyu.com/ title=安知鱼图床><img class=back-menu-item-icon src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src=https://image.anheyu.com/favicon.ico alt=安知鱼图床><span class=back-menu-item-text>安知鱼图床</span></a></div></div></div><div class=menus_items><div class=menus_item><a class=site-page href=javascript:void(0);><span>文章</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/archives/ ><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style=font-size:.9em></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/categories/ ><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style=font-size:.9em></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/tags/ ><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style=font-size:.9em></i><span> 标签</span></a></li></ul></div><div class=menus_item><a class="site-page faa-parent animated-hover" href=/album/ ><span>相册</span></a></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>娱乐</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9140460034&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style=font-size:.9em></i><span> 音乐厅</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/animations/ ><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style=font-size:.9em></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/games/ ><i class="fas fa-gamepad faa-tada"></i><span> 游戏集</span></a></li></ul></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>友链</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/link/ ><i class="anzhiyufont anzhiyu-icon-link faa-tada" style=font-size:.9em></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/comments/ ><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style=font-size:.9em></i><span> 留言板</span></a></li></ul></div><div class=menus_item><a class=site-page href=javascript:void(0);><span>关于</span></a><ul class=menus_item_child><li><a class="site-page child faa-parent animated-hover" href=/website/ ><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style=font-size:.9em></i><span> 关于网站</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/myself/ ><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style=font-size:.9em></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href=/equipment/ ><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style=font-size:.9em></i><span> 我的装备</span></a></li></ul></div></div><span class=sidebar-menu-item-title>标签</span><div class=card-tags><div class=item-headline></div><div class=card-tag-cloud><a href=/tags/C/ style=font-size:.88rem>C++<sup>1</sup></a><a href=/tags/GaN%E7%94%B5%E6%BA%90/ style=font-size:.88rem>GaN电源<sup>1</sup></a><a href=/tags/%E5%8D%9A%E5%AE%A2/ style=font-size:.88rem>博客<sup>1</sup></a><a href=/tags/%E5%BD%97%E6%98%9F/ style=font-size:.88rem>彗星<sup>1</sup></a><a href=/tags/%E6%8F%92%E4%BB%B6/ style=font-size:.88rem>插件<sup>1</sup></a><a href=/tags/%E9%A3%8E%E5%85%89/ style=font-size:.88rem>风光<sup>1</sup></a><a href=/tags/%E9%AD%94%E6%94%B9/ style=font-size:.88rem>魔改<sup>1</sup></a></div></div><hr></div></div><div id=rightside><div id=rightside-config-hide><button id=readmode type=button title=阅读模式><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id=hide-aside-btn type=button title=单栏和双栏切换><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button><button id=darkmode type=button title=浅色和深色模式转换><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><a id=to_comment href=#post-comment title=直达评论><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id=switch-commentBarrage href=javascript:anzhiyu.switchCommentBarrage(); title=开关弹幕><i class="anzhiyufont anzhiyu-icon-danmu"></i></a></div><div id=rightside-config-show><button id=rightside-config type=button title=设置><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class=close id=mobile-toc-button type=button title=目录><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id=translateLink type=button title=简繁转换>繁</button><button id=go-up type=button title=回到顶部><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id=nav-music><a id=nav-music-hoverTips onclick=anzhiyu.musicToggle() accesskey=m>播放音乐</a><div id=console-music-bg></div><meting-js id=14320891825 server=netease type=playlist mutex=true preload=none theme=var(--anzhiyu-main) data-lrctype=0 order=random volume=0.3></meting-js></div><div id=local-search><div class=search-dialog><nav class=search-nav><span class=search-dialog-title>搜索</span><span id=loading-status></span><button class=search-close-button><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class=is-center id=loading-database><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span> 数据库加载中</span></div><div class=search-wrap><div id=local-search-input><div class=local-search-box><input class=local-search-box--input placeholder=搜索文章 type=text></div></div><hr><div id=local-search-results></div></div></div><div id=search-mask></div></div><div id=rightMenu><div class="rightMenu-group rightMenu-small"><div class=rightMenu-item id=menu-backward><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class=rightMenu-item id=menu-forward><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class=rightMenu-item id=menu-refresh><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style=font-size:1rem></i></div><div class=rightMenu-item id=menu-top><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class=rightMenu-item id=menu-copytext><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class=rightMenu-item id=menu-pastetext><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class=rightMenu-item id=menu-commenttext><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class=rightMenu-item id=menu-newwindow><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class=rightMenu-item id=menu-copylink><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class=rightMenu-item id=menu-copyimg><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class=rightMenu-item id=menu-downloadimg><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class=rightMenu-item id=menu-newwindowimg><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class=rightMenu-item id=menu-search><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class=rightMenu-item id=menu-searchBaidu><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class=rightMenu-item id=menu-music-toggle><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class=rightMenu-item id=menu-music-back><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class=rightMenu-item id=menu-music-forward><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class=rightMenu-item id=menu-music-playlist onclick="window.open(&quot;https://music.163.com/#/playlist?id=14348481143&quot;, &quot;_blank&quot;);" style=display:none><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class=rightMenu-item id=menu-music-copyMusicName><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id=menu-randomPost><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href=/categories/ ><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href=/tags/ ><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class=rightMenu-item id=menu-copy href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class=rightMenu-item id=menu-commentBarrage href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-message"></i><span class=menu-commentBarrage-text>关闭热评</span></a><a class=rightMenu-item id=menu-darkmode href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class=menu-darkmode-text>深色模式</span></a><a class=rightMenu-item id=menu-translate href=javascript:void(0);><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id=rightmenu-mask></div><div><script src=/js/utils.js></script><script src=/js/main.js></script><script src=/js/tw_cn.js></script><script src=https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js></script><script src=https://cdn.cbd.int/instant.page@5.2.0/instantpage.js type=module></script><script src=https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js></script><script src=https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><canvas id=universe></canvas><script async src=https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js></script><script async src=/anzhiyu/random.js></script><script async=async>(()=>{var n,r,o,a,i,e=new Date("05/17/2025 12:00:00"),l=new Date;setInterval(()=>{var t;if(l=new Date,i=l.getHours(),t=(l-e)/1e3/60/60/24,n=Math.floor(t),t=(l-e)/1e3/60/60-24*n,r=Math.floor(t),1==String(r).length&&(r="0"+r),t=(l-e)/1e3/60-1440*n-60*r,o=Math.floor(t),1==String(o).length&&(o="0"+o),t=(l-e)/1e3-86400*n-3600*r-60*o,a=Math.round(t),1==String(a).length&&(a="0"+a),document.getElementById("footer")){let e="";e=(i<18&&9<=i||null!=(t=document.querySelector("#workboard .workSituationImg"))&&(t.src="",t.title="下班了就该开开心心的玩耍，嘿嘿~",t.alt="下班了就该开开心心的玩耍，嘿嘿~"),`本站居然运行了 ${n} 天<span id='runtime'> ${r} 小时 ${o} 分 ${a} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`),document.getElementById("runtimeTextTip")&&(document.getElementById("runtimeTextTip").innerHTML=e)}},1e3)})()</script><script src=/js/search/local-search.js></script><div class=js-pjax><script>(()=>{let t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://comment.x1ang.com",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))};var o=()=>{"object"==typeof twikoo?setTimeout(n,0):getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(n)};let e=()=>{let o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://comment.x1ang.com",region:"",urls:[window.location.pathname],includeReply:!1}).then(t=>{o.textContent=t[0].count}).catch(t=>{console.error(t)})},n=()=>{t(),GLOBAL_CONFIG_SITE.isPost&&e()};o()})()</script><input type=hidden name=page-type id=page-type value=post><script async src=/js/anzhiyu/comment_barrage.js></script></div><script>window.addEventListener("load",()=>{let t=e=>e=""!==e&&150<(e=(e=(e=(e=e.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length?e.substring(0,150)+"...":e,a=t=>{let a="";if(t.length)for(let e=0;e<t.length;e++)a=(a=(a+="<div class='aside-list-item'>")+`<a href='${t[e].url}' class='thumbnail'><img data-lazy-src='${t[e].avatar}' alt='${t[e].nick}'><div class='name'><span>${t[e].nick} </span></div></a>`)+`<div class='content'>
        <a class='comment' href='${t[e].url}' title='${t[e].content}'>${t[e].content}</a>
        <time datetime="${t[e].date}">${anzhiyu.diffDate(t[e].date,!0)}</time></div>
        </div>`;else a+="没有评论";var e=document.querySelector("#card-newest-comments .aside-list");e&&(e.innerHTML=a),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(e)};var e=()=>{var e;document.querySelector("#card-newest-comments .aside-list")&&((e=saveToLocal.get("twikoo-newest-comments"))?a(JSON.parse(e)):(e=()=>{twikoo.getRecentComments({envId:"https://comment.x1ang.com",region:"",pageSize:6,includeReply:!0}).then(function(e){e=e.map(e=>({content:t(e.comment),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(e),60/1440),a(e)}).catch(function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"})},"object"==typeof twikoo?e():getScript("https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js").then(e)))};e(),document.addEventListener("pjax:complete",e)})</script><script>var visitorMail="visitor@x1ang.com"</script><script async data-pjax src=https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js></script><script src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js></script><script src=/js/anzhiyu/right_click_menu.js></script><link rel=stylesheet href=https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css><link rel=stylesheet href=https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css media=print onload='this.media="all"'><script src=https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js></script><script src=https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js></script><script src=https://cdn.cbd.int/pjax@0.2.8/pjax.min.js></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{let t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src=https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js></script></div><div id=popup-window><div class=popup-window-title>通知</div><div class=popup-window-divider></div><div class=popup-window-content><div class=popup-tip>你好呀</div><div class=popup-link><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script async src=//at.alicdn.com/t/font_2032782_8d5kxvn09md.js></script><script src=/static/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({pluginRootPath:"static/live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/static/live2dw/assets/seifuku.model.json"},display:{position:"right",width:200,height:400},mobile:{show:!1},log:!1})</script></body></html>